"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[9108],{2732:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=t(4848),i=t(8453);const s={id:"createApi",title:"createApi",sidebar_label:"createApi",hide_title:!0,description:"RTK Query > API: createApi reference"},a="createApi",o={id:"rtk-query/api/createApi",title:"createApi",description:"RTK Query > API: createApi reference",source:"@site/docs/rtk-query/api/createApi.mdx",sourceDirName:"rtk-query/api",slug:"/rtk-query/api/createApi",permalink:"/redux-toolkit-zh/rtk-query/api/createApi",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rtk-query/api/createApi.mdx",tags:[],version:"current",frontMatter:{id:"createApi",title:"createApi",sidebar_label:"createApi",hide_title:!0,description:"RTK Query > API: createApi reference"},sidebar:"docs",previous:{title:"\u8fc1\u79fb\u5230 RTK Query",permalink:"/redux-toolkit-zh/rtk-query/usage/migrating-to-rtk-query"},next:{title:"fetchBaseQuery",permalink:"/redux-toolkit-zh/rtk-query/api/fetchBaseQuery"}},d={},c=[{value:"Parameters",id:"parameters",level:2},{value:"<code>baseQuery</code>",id:"basequery",level:3},{value:"baseQuery function arguments",id:"basequery-function-arguments",level:4},{value:"baseQuery function signature",id:"basequery-function-signature",level:4},{value:"<code>endpoints</code>",id:"endpoints",level:3},{value:"Query endpoint definition",id:"query-endpoint-definition",level:4},{value:"Mutation endpoint definition",id:"mutation-endpoint-definition",level:4},{value:"How endpoints get used",id:"how-endpoints-get-used",level:4},{value:"<code>extractRehydrationInfo</code>",id:"extractrehydrationinfo",level:3},{value:"<code>tagTypes</code>",id:"tagtypes",level:3},{value:"<code>reducerPath</code>",id:"reducerpath",level:3},{value:"<code>serializeQueryArgs</code>",id:"serializequeryargs",level:3},{value:"<code>keepUnusedDataFor</code>",id:"keepunuseddatafor",level:3},{value:"<code>refetchOnMountOrArgChange</code>",id:"refetchonmountorargchange",level:3},{value:"<code>refetchOnFocus</code>",id:"refetchonfocus",level:3},{value:"<code>refetchOnReconnect</code>",id:"refetchonreconnect",level:3},{value:"Anatomy of an endpoint",id:"anatomy-of-an-endpoint",level:2},{value:"<code>query</code>",id:"query",level:3},{value:"<code>queryFn</code>",id:"queryfn",level:3},{value:"queryFn function arguments",id:"queryfn-function-arguments",level:4},{value:"<code>transformResponse</code>",id:"transformresponse",level:3},{value:"<code>transformErrorResponse</code>",id:"transformerrorresponse",level:3},{value:"<code>extraOptions</code>",id:"extraoptions",level:3},{value:"<code>providesTags</code>",id:"providestags",level:3},{value:"<code>invalidatesTags</code>",id:"invalidatestags",level:3},{value:"<code>keepUnusedDataFor</code>",id:"keepunuseddatafor-1",level:3},{value:"<code>serializeQueryArgs</code>",id:"serializequeryargs-1",level:3},{value:"<code>merge</code>",id:"merge",level:3},{value:"<code>forceRefetch</code>",id:"forcerefetch",level:3},{value:"<code>onQueryStarted</code>",id:"onquerystarted",level:3},{value:"Lifecycle API properties",id:"lifecycle-api-properties",level:4},{value:"<code>onCacheEntryAdded</code>",id:"oncacheentryadded",level:3},{value:"Cache Lifecycle API properties",id:"cache-lifecycle-api-properties",level:4},{value:"Return value",id:"return-value",level:2}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"\xa0"}),"\n",(0,r.jsx)(n.h1,{id:"createapi",children:(0,r.jsx)(n.code,{children:"createApi"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"createApi"}),' is the core of RTK Query\'s functionality. It allows you to define a set of "endpoints" that describe how to retrieve data from backend APIs and other async sources, including the configuration of how to fetch and transform that data. It generates ',(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/overview",children:'an "API slice" structure'})," that contains Redux logic (and optionally React hooks) that encapsulate the data fetching and caching process for you."]}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["Typically, you should only have one API slice per base URL that your application needs to communicate with. For example, if your site fetches data from both ",(0,r.jsx)(n.code,{children:"/api/posts"})," and ",(0,r.jsx)(n.code,{children:"/api/users"}),", you would have a single API slice with ",(0,r.jsx)(n.code,{children:"/api/"})," as the base URL, and separate endpoint definitions for ",(0,r.jsx)(n.code,{children:"posts"})," and ",(0,r.jsx)(n.code,{children:"users"}),". This allows you to effectively take advantage of ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/automated-refetching",children:"automated re-fetching"})," by defining ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/automated-refetching#tags",children:"tag"})," relationships across endpoints."]}),(0,r.jsxs)(n.p,{children:["For maintainability purposes, you may wish to split up endpoint definitions across multiple files, while still maintaining a single API slice which includes all of these endpoints. See ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/code-splitting",children:"code splitting"})," for how you can use the ",(0,r.jsx)(n.code,{children:"injectEndpoints"})," property to inject API endpoints from other files into a single API slice definition."]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Example: src/services/pokemon.ts"',children:"// file: src/services/types.ts noEmit\nexport type Pokemon = {}\n\n// file: src/services/pokemon.ts\n// Need to use the React-specific entry point to allow generating React hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Pokemon } from './types'\n\n// highlight-start\n// Define a service using a base URL and expected endpoints\nexport const pokemonApi = createApi({\n  reducerPath: 'pokemonApi',\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (builder) => ({\n    getPokemonByName: builder.query<Pokemon, string>({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n//highlight-end\n\n// highlight-start\n// Export hooks for usage in function components, which are\n// auto-generated based on the defined endpoints\nexport const { useGetPokemonByNameQuery } = pokemonApi\n// highlight-end\n"})}),"\n",(0,r.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"createApi"})," accepts a single configuration object parameter with the following options:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"  baseQuery(args: InternalQueryArgs, api: BaseQueryApi, extraOptions?: DefinitionExtraOptions): any;\n  endpoints(build: EndpointBuilder<InternalQueryArgs, TagTypes>): Definitions;\n  extractRehydrationInfo?: (\n    action: UnknownAction,\n    {\n      reducerPath,\n    }: {\n      reducerPath: ReducerPath\n    }\n  ) =>\n    | undefined\n    | CombinedState<Definitions, TagTypes, ReducerPath>\n  tagTypes?: readonly TagTypes[];\n  reducerPath?: ReducerPath;\n  serializeQueryArgs?: SerializeQueryArgs<InternalQueryArgs>;\n  keepUnusedDataFor?: number; // value is in seconds\n  refetchOnMountOrArgChange?: boolean | number; // value is in seconds\n  refetchOnFocus?: boolean;\n  refetchOnReconnect?: boolean;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"basequery",children:(0,r.jsx)(n.code,{children:"baseQuery"})}),"\n",(0,r.jsxs)(n.p,{children:["The base query used by each endpoint if no ",(0,r.jsx)(n.code,{children:"queryFn"})," option is specified. RTK Query exports a utility called ",(0,r.jsx)(n.a,{href:"./fetchBaseQuery",children:"fetchBaseQuery"})," as a lightweight wrapper around ",(0,r.jsx)(n.code,{children:"fetch"})," for common use-cases. See ",(0,r.jsx)(n.a,{href:"../../rtk-query/usage/customizing-queries",children:"Customizing Queries"})," if ",(0,r.jsx)(n.code,{children:"fetchBaseQuery"})," does not handle your requirements."]}),"\n",(0,r.jsx)(n.h4,{id:"basequery-function-arguments",children:"baseQuery function arguments"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"args"})," - The return value of the ",(0,r.jsx)(n.code,{children:"query"})," function for a given endpoint"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"api"})," - The ",(0,r.jsx)(n.code,{children:"BaseQueryApi"})," object contains:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signal"})," - An ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:(0,r.jsx)(n.code,{children:"AbortSignal"})})," object that may be used to abort DOM requests and/or read whether the request is aborted."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"abort"})," - The ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort",children:(0,r.jsx)(n.code,{children:"abort()"})})," method of the AbortController attached to ",(0,r.jsx)(n.code,{children:"signal"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dispatch"})," - The ",(0,r.jsx)(n.code,{children:"store.dispatch"})," method for the corresponding Redux store"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getState"})," - A function that may be called to access the current store state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extra"})," - Provided as thunk.extraArgument to the configureStore getDefaultMiddleware option."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"endpoint"})," - The name of the endpoint."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"})," - Type of request (",(0,r.jsx)(n.code,{children:"query"})," or ",(0,r.jsx)(n.code,{children:"mutation"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"forced"})," - Indicates if a query has been forced."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extraOptions"})," - The value of the optional ",(0,r.jsx)(n.code,{children:"extraOptions"})," property provided for a given endpoint"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"basequery-function-signature",children:"baseQuery function signature"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Base Query signature" no-transpile',children:"export type BaseQueryFn<\n  Args = any,\n  Result = unknown,\n  Error = unknown,\n  DefinitionExtraOptions = {},\n  Meta = {},\n> = (\n  args: Args,\n  api: BaseQueryApi,\n  extraOptions: DefinitionExtraOptions,\n) => MaybePromise<QueryReturnValue<Result, Error, Meta>>\n\nexport interface BaseQueryApi {\n  signal: AbortSignal\n  abort: (reason?: string) => void\n  dispatch: ThunkDispatch<any, any, any>\n  getState: () => unknown\n  extra: unknown\n  endpoint: string\n  type: 'query' | 'mutation'\n  forced?: boolean\n}\n\nexport type QueryReturnValue<T = unknown, E = unknown, M = unknown> =\n  | {\n      error: E\n      data?: undefined\n      meta?: M\n    }\n  | {\n      error?: undefined\n      data: T\n      meta?: M\n    }\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-end\n  endpoints: (build) => ({\n    // ...endpoints\n  }),\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"endpoints",children:(0,r.jsx)(n.code,{children:"endpoints"})}),"\n",(0,r.jsxs)(n.p,{children:["Endpoints are just a set of operations that you want to perform against your server. You define them as an object using the builder syntax. There are two basic endpoint types: ",(0,r.jsx)(n.a,{href:"../../rtk-query/usage/queries",children:(0,r.jsx)(n.code,{children:"query"})})," and ",(0,r.jsx)(n.a,{href:"../../rtk-query/usage/mutations",children:(0,r.jsx)(n.code,{children:"mutation"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"#anatomy-of-an-endpoint",children:"Anatomy of an endpoint"})," for details on individual properties."]}),"\n",(0,r.jsx)(n.h4,{id:"query-endpoint-definition",children:"Query endpoint definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Query endpoint definition" no-transpile',children:"export type QueryDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> = {\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>\n\n  /* either `query` or `queryFn` can be present, but not both simultaneously */\n  queryFn(\n    arg: QueryArg,\n    api: BaseQueryApi,\n    extraOptions: BaseQueryExtraOptions<BaseQuery>,\n    baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>,\n  ): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>>>\n\n  /* transformResponse only available with `query`, not `queryFn` */\n  transformResponse?(\n    baseQueryReturnValue: BaseQueryResult<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): ResultType | Promise<ResultType>\n\n  /* transformErrorResponse only available with `query`, not `queryFn` */\n  transformErrorResponse?(\n    baseQueryReturnValue: BaseQueryError<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): unknown\n\n  extraOptions?: BaseQueryExtraOptions<BaseQuery>\n\n  providesTags?: ResultDescription<\n    TagTypes,\n    ResultType,\n    QueryArg,\n    BaseQueryError<BaseQuery>\n  >\n\n  keepUnusedDataFor?: number\n\n  onQueryStarted?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      queryFulfilled,\n      getCacheEntry,\n      updateCachedData, // available for query endpoints only\n    }: QueryLifecycleApi,\n  ): Promise<void>\n\n  onCacheEntryAdded?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      cacheEntryRemoved,\n      cacheDataLoaded,\n      getCacheEntry,\n      updateCachedData, // available for query endpoints only\n    }: QueryCacheLifecycleApi,\n  ): Promise<void>\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"mutation-endpoint-definition",children:"Mutation endpoint definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Mutation endpoint definition" no-transpile',children:"export type MutationDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n  Context = Record<string, any>,\n> = {\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>\n\n  /* either `query` or `queryFn` can be present, but not both simultaneously */\n  queryFn(\n    arg: QueryArg,\n    api: BaseQueryApi,\n    extraOptions: BaseQueryExtraOptions<BaseQuery>,\n    baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>,\n  ): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>>>\n\n  /* transformResponse only available with `query`, not `queryFn` */\n  transformResponse?(\n    baseQueryReturnValue: BaseQueryResult<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): ResultType | Promise<ResultType>\n\n  /* transformErrorResponse only available with `query`, not `queryFn` */\n  transformErrorResponse?(\n    baseQueryReturnValue: BaseQueryError<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): unknown\n\n  extraOptions?: BaseQueryExtraOptions<BaseQuery>\n\n  invalidatesTags?: ResultDescription<TagTypes, ResultType, QueryArg>\n\n  onQueryStarted?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      queryFulfilled,\n      getCacheEntry,\n    }: MutationLifecycleApi,\n  ): Promise<void>\n\n  onCacheEntryAdded?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      cacheEntryRemoved,\n      cacheDataLoaded,\n      getCacheEntry,\n    }: MutationCacheLifecycleApi,\n  ): Promise<void>\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"how-endpoints-get-used",children:"How endpoints get used"}),"\n",(0,r.jsxs)(n.p,{children:["When defining a key like ",(0,r.jsx)(n.code,{children:"getPosts"})," as shown below, it's important to know that this name will become exportable from ",(0,r.jsx)(n.code,{children:"api"})," and be able to referenced under ",(0,r.jsx)(n.code,{children:"api.endpoints.getPosts.useQuery()"}),", ",(0,r.jsx)(n.code,{children:"api.endpoints.getPosts.initiate()"})," and ",(0,r.jsx)(n.code,{children:"api.endpoints.getPosts.select()"}),". The same thing applies to ",(0,r.jsx)(n.code,{children:"mutation"}),"s but they reference ",(0,r.jsx)(n.code,{children:"useMutation"})," instead of ",(0,r.jsx)(n.code,{children:"useQuery"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result ? result.map(({ id }) => ({ type: 'Posts', id })) : [],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query: (body) => ({\n        url: `posts`,\n        method: 'POST',\n        body,\n      }),\n      invalidatesTags: ['Posts'],\n    }),\n  }),\n})\n\n// Auto-generated hooks\nexport const { useGetPostsQuery, useAddPostMutation } = api\n\n// Possible exports\nexport const { endpoints, reducerPath, reducer, middleware } = api\n// reducerPath, reducer, middleware are only used in store configuration\n// endpoints will have:\n// endpoints.getPosts.initiate(), endpoints.getPosts.select(), endpoints.getPosts.useQuery()\n// endpoints.addPost.initiate(), endpoints.addPost.select(), endpoints.addPost.useMutation()\n// see `createApi` overview for _all exports_\n"})}),"\n",(0,r.jsx)(n.h3,{id:"extractrehydrationinfo",children:(0,r.jsx)(n.code,{children:"extractRehydrationInfo"})}),"\n",(0,r.jsxs)(n.p,{children:["A function that is passed every dispatched action. If this returns something other than ",(0,r.jsx)(n.code,{children:"undefined"}),",\nthat return value will be used to rehydrate fulfilled & errored queries."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="next-redux-wrapper rehydration example"',children:"import type { Action, PayloadAction } from '@reduxjs/toolkit'\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { HYDRATE } from 'next-redux-wrapper'\n\ntype RootState = any; // normally inferred from state\n\nfunction isHydrateAction(action: Action): action is PayloadAction<RootState> {\n  return action.type === HYDRATE\n}\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-start\n  extractRehydrationInfo(action, { reducerPath }): any {\n    if (isHydrateAction(action)) {\n      return action.payload[reducerPath]\n    }\n  },\n  // highlight-end\n  endpoints: (build) => ({\n    // omitted\n  }),\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/server-side-rendering",children:"Server Side Rendering"})," and\n",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/persistence-and-rehydration",children:"Persistence and Rehydration"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"tagtypes",children:(0,r.jsx)(n.code,{children:"tagTypes"})}),"\n",(0,r.jsxs)(n.p,{children:["An array of string tag type names. Specifying tag types is optional, but you should define them so that they can be used for caching and invalidation. When defining a tag type, you will be able to ",(0,r.jsx)(n.a,{href:"../../rtk-query/usage/automated-refetching#providing-tags",children:"provide"})," them with ",(0,r.jsx)(n.code,{children:"providesTags"})," and ",(0,r.jsx)(n.a,{href:"../../rtk-query/usage/automated-refetching#invalidating-tags",children:"invalidate"})," them with ",(0,r.jsx)(n.code,{children:"invalidatesTags"})," when configuring ",(0,r.jsx)(n.a,{href:"#endpoints",children:"endpoints"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-start\n  tagTypes: ['Post', 'User'],\n  // highlight-end\n  endpoints: (build) => ({\n    // ...endpoints\n  }),\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"reducerpath",children:(0,r.jsx)(n.code,{children:"reducerPath"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"reducerPath"})," is a ",(0,r.jsx)(n.em,{children:"unique"})," key that your service will be mounted to in your store. If you call ",(0,r.jsx)(n.code,{children:"createApi"})," more than once in your application, you will need to provide a unique value each time. Defaults to ",(0,r.jsx)(n.code,{children:"'api'"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="apis.js"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query';\n\nconst apiOne = createApi({\n  // highlight-start\n  reducerPath: 'apiOne',\n  // highlight-end\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (builder) => ({\n    // ...endpoints\n  }),\n});\n\nconst apiTwo = createApi({\n  // highlight-start\n  reducerPath: 'apiTwo',\n  // highlight-end\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (builder) => ({\n    // ...endpoints\n  }),\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"serializequeryargs",children:(0,r.jsx)(n.code,{children:"serializeQueryArgs"})}),"\n",(0,r.jsx)(n.p,{children:"Accepts a custom function if you have a need to change the creation of cache keys for any reason."}),"\n",(0,r.jsx)(n.p,{children:"By default, this function will take the query arguments, sort object keys where applicable, stringify the result, and concatenate it with the endpoint name. This creates a cache key based on the combination of arguments + endpoint name (ignoring object key order), such that calling any given endpoint with the same arguments will result in the same cache key."}),"\n",(0,r.jsx)(n.h3,{id:"keepunuseddatafor",children:(0,r.jsx)(n.code,{children:"keepUnusedDataFor"})}),"\n",(0,r.jsxs)(n.p,{children:["Defaults to ",(0,r.jsx)(n.code,{children:"60"})," ",(0,r.jsx)(n.em,{children:"(this value is in seconds)"}),". This is how long RTK Query will keep your data cached for ",(0,r.jsx)(n.strong,{children:"after"})," the last component unsubscribes. For example, if you query an endpoint, then unmount the component, then mount another component that makes the same request within the given time frame, the most recent value will be served from the cache."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="keepUnusedDataFor example"',children:"\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      keepUnusedDataFor: 5\n      // highlight-end\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"refetchonmountorargchange",children:(0,r.jsx)(n.code,{children:"refetchOnMountOrArgChange"})}),"\n",(0,r.jsxs)(n.p,{children:["Defaults to ",(0,r.jsx)(n.code,{children:"false"}),". This setting allows you to control whether if a cached result is already available RTK Query will only serve a cached result, or if it should ",(0,r.jsx)(n.code,{children:"refetch"})," when set to ",(0,r.jsx)(n.code,{children:"true"})," or if an adequate amount of time has passed since the last successful query result."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"false"})," - Will not cause a query to be performed ",(0,r.jsx)(n.em,{children:"unless"})," it does not exist yet."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"true"})," - Will always refetch when a new subscriber to a query is added. Behaves the same as calling the ",(0,r.jsx)(n.code,{children:"refetch"})," callback or passing ",(0,r.jsx)(n.code,{children:"forceRefetch: true"})," in the action creator."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"number"})," - ",(0,r.jsx)(n.strong,{children:"Value is in seconds"}),". If a number is provided and there is an existing query in the cache, it will compare the current time vs the last fulfilled timestamp, and only refetch if enough time has elapsed."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If you specify this option alongside ",(0,r.jsx)(n.code,{children:"skip: true"}),", this ",(0,r.jsx)(n.strong,{children:"will not be evaluated"})," until ",(0,r.jsx)(n.code,{children:"skip"})," is false."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["You can set this globally in ",(0,r.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,r.jsx)(n.code,{children:"refetchOnMountOrArgChange"})," to each individual hook call or similarly by passing ",(0,r.jsx)(n.code,{children:"forceRefetch: true"})," when dispatching the ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/endpoints#initiate",children:(0,r.jsx)(n.code,{children:"initiate"})})," action."]})}),"\n",(0,r.jsx)(n.h3,{id:"refetchonfocus",children:(0,r.jsx)(n.code,{children:"refetchOnFocus"})}),"\n",(0,r.jsxs)(n.p,{children:["Defaults to ",(0,r.jsx)(n.code,{children:"false"}),". This setting allows you to control whether RTK Query will try to refetch all subscribed queries after the application window regains focus."]}),"\n",(0,r.jsxs)(n.p,{children:["If you specify this option alongside ",(0,r.jsx)(n.code,{children:"skip: true"}),", this ",(0,r.jsx)(n.strong,{children:"will not be evaluated"})," until ",(0,r.jsx)(n.code,{children:"skip"})," is false."]}),"\n",(0,r.jsxs)(n.p,{children:["Note: requires ",(0,r.jsx)(n.a,{href:"./setupListeners",children:(0,r.jsx)(n.code,{children:"setupListeners"})})," to have been called."]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["You can set this globally in ",(0,r.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,r.jsx)(n.code,{children:"refetchOnFocus"})," to each individual hook call or when dispatching the ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/endpoints#initiate",children:(0,r.jsx)(n.code,{children:"initiate"})})," action."]}),(0,r.jsxs)(n.p,{children:["If you specify ",(0,r.jsx)(n.code,{children:"track: false"})," when manually dispatching queries, RTK Query will not be able to automatically refetch for you."]})]}),"\n",(0,r.jsx)(n.h3,{id:"refetchonreconnect",children:(0,r.jsx)(n.code,{children:"refetchOnReconnect"})}),"\n",(0,r.jsxs)(n.p,{children:["Defaults to ",(0,r.jsx)(n.code,{children:"false"}),". This setting allows you to control whether RTK Query will try to refetch all subscribed queries after regaining a network connection."]}),"\n",(0,r.jsxs)(n.p,{children:["If you specify this option alongside ",(0,r.jsx)(n.code,{children:"skip: true"}),", this ",(0,r.jsx)(n.strong,{children:"will not be evaluated"})," until ",(0,r.jsx)(n.code,{children:"skip"})," is false."]}),"\n",(0,r.jsxs)(n.p,{children:["Note: requires ",(0,r.jsx)(n.a,{href:"./setupListeners",children:(0,r.jsx)(n.code,{children:"setupListeners"})})," to have been called."]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["You can set this globally in ",(0,r.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,r.jsx)(n.code,{children:"refetchOnReconnect"})," to each individual hook call or when dispatching the ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/endpoints#initiate",children:(0,r.jsx)(n.code,{children:"initiate"})})," action."]}),(0,r.jsxs)(n.p,{children:["If you specify ",(0,r.jsx)(n.code,{children:"track: false"})," when manually dispatching queries, RTK Query will not be able to automatically refetch for you."]})]}),"\n",(0,r.jsx)(n.h2,{id:"anatomy-of-an-endpoint",children:"Anatomy of an endpoint"}),"\n",(0,r.jsx)(n.h3,{id:"query",children:(0,r.jsx)(n.code,{children:"query"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["(required if no ",(0,r.jsx)(n.code,{children:"queryFn"})," provided)"]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="query signature" no-transpile',children:"export type query = <QueryArg>(\n  arg: QueryArg,\n) => string | Record<string, unknown>\n\n// with `fetchBaseQuery`\nexport type query = <QueryArg>(arg: QueryArg) => string | FetchArgs\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"query"})," can be a function that returns either a ",(0,r.jsx)(n.code,{children:"string"})," or an ",(0,r.jsx)(n.code,{children:"object"})," which is passed to your ",(0,r.jsx)(n.code,{children:"baseQuery"}),". If you are using ",(0,r.jsx)(n.a,{href:"./fetchBaseQuery",children:"fetchBaseQuery"}),", this can return either a ",(0,r.jsx)(n.code,{children:"string"})," or an ",(0,r.jsx)(n.code,{children:"object"})," of properties in ",(0,r.jsx)(n.code,{children:"FetchArgs"}),". If you use your own custom ",(0,r.jsx)(n.a,{href:"../../rtk-query/usage/customizing-queries",children:(0,r.jsx)(n.code,{children:"baseQuery"})}),", you can customize this behavior to your liking."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="query example"',children:"\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      // highlight-start\n      query: () => 'posts',\n      // highlight-end\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n     // highlight-start\n     query: (body) => ({\n       url: `posts`,\n       method: 'POST',\n       body,\n     }),\n     // highlight-end\n     invalidatesTags: [{ type: 'Post', id: 'LIST' }],\n   }),\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"queryfn",children:(0,r.jsx)(n.code,{children:"queryFn"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["(required if no ",(0,r.jsx)(n.code,{children:"query"})," provided)"]})}),"\n",(0,r.jsxs)(n.p,{children:["Can be used in place of ",(0,r.jsx)(n.code,{children:"query"})," as an inline function that bypasses ",(0,r.jsx)(n.code,{children:"baseQuery"})," completely for the endpoint."]}),"\n",(0,r.jsxs)(n.p,{children:["Called with the same arguments as ",(0,r.jsx)(n.code,{children:"baseQuery"}),", as well as the provided ",(0,r.jsx)(n.code,{children:"baseQuery"})," function itself. It is expected to return an object with either a ",(0,r.jsx)(n.code,{children:"data"})," or ",(0,r.jsx)(n.code,{children:"error"})," property, or a promise that resolves to return such an object."]}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/customizing-queries#customizing-queries-with-queryfn",children:"Customizing queries with queryFn"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="queryFn signature" no-transpile',children:"queryFn(\n  arg: QueryArg,\n  api: BaseQueryApi,\n  extraOptions: BaseQueryExtraOptions<BaseQuery>,\n  baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>\n): MaybePromise<\n| {\n    error: BaseQueryError<BaseQuery>\n    data?: undefined\n  }\n| {\n    error?: undefined\n    data: ResultType\n  }\n>\n\nexport interface BaseQueryApi {\n  signal: AbortSignal\n  dispatch: ThunkDispatch<any, any, any>\n  getState: () => unknown\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"queryfn-function-arguments",children:"queryFn function arguments"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"args"})," - The argument provided when the query itself is called"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"api"})," - The ",(0,r.jsx)(n.code,{children:"BaseQueryApi"})," object, containing ",(0,r.jsx)(n.code,{children:"signal"}),", ",(0,r.jsx)(n.code,{children:"dispatch"})," and ",(0,r.jsx)(n.code,{children:"getState"})," properties","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signal"})," - An ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:(0,r.jsx)(n.code,{children:"AbortSignal"})})," object that may be used to abort DOM requests and/or read whether the request is aborted."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dispatch"})," - The ",(0,r.jsx)(n.code,{children:"store.dispatch"})," method for the corresponding Redux store"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getState"})," - A function that may be called to access the current store state"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extraOptions"})," - The value of the optional ",(0,r.jsx)(n.code,{children:"extraOptions"})," property provided for the endpoint"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"baseQuery"})," - The ",(0,r.jsx)(n.code,{children:"baseQuery"})," function provided to the api itself"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Basic queryFn example"',children:"\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n    }),\n    flipCoin: build.query<'heads' | 'tails', void>({\n      // highlight-start\n      queryFn(arg, queryApi, extraOptions, baseQuery) {\n        const randomVal = Math.random()\n        if (randomVal < 0.45) {\n          return { data: 'heads' }\n        }\n        if (randomVal < 0.9) {\n          return { data: 'tails' }\n        }\n        return { error: { status: 500, statusText: 'Internal Server Error', data: \"Coin landed on it's edge!\" } }\n      }\n      // highlight-end\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"transformresponse",children:(0,r.jsx)(n.code,{children:"transformResponse"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["(optional, not applicable with ",(0,r.jsx)(n.code,{children:"queryFn"}),")"]})}),"\n",(0,r.jsx)(n.p,{children:"A function to manipulate the data returned by a query or mutation."}),"\n",(0,r.jsxs)(n.p,{children:["In some cases, you may want to manipulate the data returned from a query before you put it in the cache. In this instance, you can take advantage of ",(0,r.jsx)(n.code,{children:"transformResponse"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsxs)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/customizing-queries#customizing-query-responses-with-transformresponse",children:["Customizing query responses with ",(0,r.jsx)(n.code,{children:"transformResponse"})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Unpack a deeply nested collection" no-transpile',children:"transformResponse: (response, meta, arg) =>\n  response.some.deeply.nested.collection\n"})}),"\n",(0,r.jsx)(n.h3,{id:"transformerrorresponse",children:(0,r.jsx)(n.code,{children:"transformErrorResponse"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["(optional, not applicable with ",(0,r.jsx)(n.code,{children:"queryFn"}),")"]})}),"\n",(0,r.jsx)(n.p,{children:"A function to manipulate the data returned by a failed query or mutation."}),"\n",(0,r.jsxs)(n.p,{children:["In some cases, you may want to manipulate the error returned from a query before you put it in the cache. In this instance, you can take advantage of ",(0,r.jsx)(n.code,{children:"transformErrorResponse"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsxs)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/customizing-queries#customizing-query-responses-with-transformerrorresponse",children:["Customizing query responses with ",(0,r.jsx)(n.code,{children:"transformErrorResponse"})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Unpack a deeply nested error object" no-transpile',children:"transformErrorResponse: (response, meta, arg) =>\n  response.data.some.deeply.nested.errorObject\n"})}),"\n",(0,r.jsx)(n.h3,{id:"extraoptions",children:(0,r.jsx)(n.code,{children:"extraOptions"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional)"})}),"\n",(0,r.jsxs)(n.p,{children:["Passed as the third argument to the supplied ",(0,r.jsx)(n.code,{children:"baseQuery"})," function"]}),"\n",(0,r.jsx)(n.h3,{id:"providestags",children:(0,r.jsx)(n.code,{children:"providesTags"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,r.jsxs)(n.p,{children:["Used by ",(0,r.jsx)(n.code,{children:"query"})," endpoints. Determines which 'tag' is attached to the cached data returned by the query.\nExpects an array of tag type strings, an array of objects of tag types with ids, or a function that returns such an array."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"['Post']"})," - equivalent to ",(0,r.jsx)(n.code,{children:"2"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"[{ type: 'Post' }]"})," - equivalent to ",(0,r.jsx)(n.code,{children:"1"})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"[{ type: 'Post', id: 1 }]"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"(result, error, arg) => ['Post']"})," - equivalent to ",(0,r.jsx)(n.code,{children:"5"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"(result, error, arg) => [{ type: 'Post' }]"})," - equivalent to ",(0,r.jsx)(n.code,{children:"4"})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(result, error, arg) => [{ type: 'Post', id: 1 }]"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/automated-refetching#providing-cache-data",children:"Providing cache data"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="providesTags example"',children:"\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n      // highlight-end\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"invalidatestags",children:(0,r.jsx)(n.code,{children:"invalidatesTags"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional, only for mutation endpoints)"})}),"\n",(0,r.jsxs)(n.p,{children:["Used by ",(0,r.jsx)(n.code,{children:"mutation"})," endpoints. Determines which cached data should be either re-fetched or removed from the cache.\nExpects the same shapes as ",(0,r.jsx)(n.code,{children:"providesTags"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/automated-refetching#invalidating-cache-data",children:"Invalidating cache data"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="invalidatesTags example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query(body) {\n        return {\n          url: `posts`,\n          method: 'POST',\n          body,\n        }\n      },\n      // highlight-start\n      invalidatesTags: [{ type: 'Posts', id: 'LIST' }],\n      // highlight-end\n    }),\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"keepunuseddatafor-1",children:(0,r.jsx)(n.code,{children:"keepUnusedDataFor"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,r.jsxs)(n.p,{children:["Overrides the api-wide definition of ",(0,r.jsx)(n.code,{children:"keepUnusedDataFor"})," for this endpoint only."]}),"\n",(0,r.jsxs)(n.p,{children:["Defaults to ",(0,r.jsx)(n.code,{children:"60"})," ",(0,r.jsx)(n.em,{children:"(this value is in seconds)"}),". This is how long RTK Query will keep your data cached for ",(0,r.jsx)(n.strong,{children:"after"})," the last component unsubscribes. For example, if you query an endpoint, then unmount the component, then mount another component that makes the same request within the given time frame, the most recent value will be served from the cache."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="keepUnusedDataFor example"',children:"\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      keepUnusedDataFor: 5\n      // highlight-end\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"serializequeryargs-1",children:(0,r.jsx)(n.code,{children:"serializeQueryArgs"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,r.jsx)(n.p,{children:"Can be provided to return a custom cache key value based on the query arguments."}),"\n",(0,r.jsx)(n.p,{children:"This is primarily intended for cases where a non-serializable value is passed as part of the query arg object and should be excluded from the cache key.  It may also be used for cases where an endpoint should only have a single cache entry, such as an infinite loading / pagination implementation."}),"\n",(0,r.jsxs)(n.p,{children:["Unlike the ",(0,r.jsx)(n.code,{children:"createApi"})," version which can ",(0,r.jsx)(n.em,{children:"only"})," return a string, this per-endpoint option can also return an an object, number, or boolean.  If it returns a string, that value will be used as the cache key directly.  If it returns an object / number / boolean, that value will be passed to the built-in ",(0,r.jsx)(n.code,{children:"defaultSerializeQueryArgs"}),".  This simplifies the use case of stripping out args you don't want included in the cache key."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="serializeQueryArgs : exclude value"',children:"\nimport { createApi, fetchBaseQuery, defaultSerializeQueryArgs } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\n\ninterface MyApiClient {\n  fetchPost: (id: string) => Promise<Post>\n}\n\ncreateApi({\n baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n endpoints: (build) => ({\n   // Example: an endpoint with an API client passed in as an argument,\n   // but only the item ID should be used as the cache key\n   getPost: build.query<Post, { id: string; client: MyApiClient }>({\n     queryFn: async ({ id, client }) => {\n       const post = await client.fetchPost(id)\n       return { data: post }\n     },\n     // highlight-start\n     serializeQueryArgs: ({ queryArgs, endpointDefinition, endpointName }) => {\n       const { id } = queryArgs\n       // This can return a string, an object, a number, or a boolean.\n       // If it returns an object, number or boolean, that value\n       // will be serialized automatically via `defaultSerializeQueryArgs`\n       return { id } // omit `client` from the cache key\n\n       // Alternately, you can use `defaultSerializeQueryArgs` yourself:\n       // return defaultSerializeQueryArgs({\n       //   endpointName,\n       //   queryArgs: { id },\n       //   endpointDefinition\n       // })\n       // Or  create and return a string yourself:\n       // return `getPost(${id})`\n     },\n     // highlight-end\n   }),\n }),\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"merge",children:(0,r.jsx)(n.code,{children:"merge"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,r.jsx)(n.p,{children:"Can be provided to merge an incoming response value into the current cache data.\nIf supplied, no automatic structural sharing will be applied - it's up to\nyou to update the cache appropriately."}),"\n",(0,r.jsxs)(n.p,{children:["Since RTKQ normally replaces cache entries with the new response, you will usually\nneed to use this with the ",(0,r.jsx)(n.code,{children:"serializeQueryArgs"})," or ",(0,r.jsx)(n.code,{children:"forceRefetch"})," options to keep\nan existing cache entry so that it can be updated."]}),"\n",(0,r.jsxs)(n.p,{children:["Since this is wrapped with Immer, you may either mutate the ",(0,r.jsx)(n.code,{children:"currentCacheValue"})," directly,\nor return a new value, but ",(0,r.jsx)(n.em,{children:"not"})," both at once."]}),"\n",(0,r.jsxs)(n.p,{children:["Will only be called if the existing ",(0,r.jsx)(n.code,{children:"currentCacheData"})," is ",(0,r.jsx)(n.em,{children:"not"})," ",(0,r.jsx)(n.code,{children:"undefined"})," - on first response,\nthe cache entry will just save the response data directly."]}),"\n",(0,r.jsx)(n.p,{children:"Useful if you don't want a new request to completely override the current cache value,\nmaybe because you have manually updated it from another source and don't want those\nupdates to get lost."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="merge: pagination"',children:"\nimport { createApi, fetchBaseQuery, defaultSerializeQueryArgs } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\n\ncreateApi({\n baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n endpoints: (build) => ({\n   listItems: build.query<string[], number>({\n     query: (pageNumber) => `/listItems?page=${pageNumber}`,\n    // Only have one cache entry because the arg always maps to one string\n    serializeQueryArgs: ({ endpointName }) => {\n      return endpointName\n     },\n     // Always merge incoming data to the cache entry\n     merge: (currentCache, newItems) => {\n       currentCache.push(...newItems)\n     },\n     // Refetch when the page arg changes\n     forceRefetch({ currentArg, previousArg }) {\n       return currentArg !== previousArg\n     },\n   }),\n }),\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"forcerefetch",children:(0,r.jsx)(n.code,{children:"forceRefetch"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="forceRefetch signature" no-transpile',children:"type forceRefetch = (params: {\n  currentArg: QueryArg | undefined\n  previousArg: QueryArg | undefined\n  state: RootState<any, any, string>\n  endpointState?: QuerySubState<any>\n}) => boolean\n"})}),"\n",(0,r.jsxs)(n.p,{children:['Check to see if the endpoint should force a refetch in cases where it normally wouldn\'t.\nThis is primarily useful for "infinite scroll" / pagination use cases where\nRTKQ is keeping a single cache entry that is added to over time, in combination\nwith ',(0,r.jsx)(n.code,{children:"serializeQueryArgs"})," returning a fixed cache key and a ",(0,r.jsx)(n.code,{children:"merge"})," callback\nset to add incoming data to the cache entry each time."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="forceRefresh: pagination"',children:"\nimport { createApi, fetchBaseQuery, defaultSerializeQueryArgs } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\n\ncreateApi({\n baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n endpoints: (build) => ({\n   listItems: build.query<string[], number>({\n     query: (pageNumber) => `/listItems?page=${pageNumber}`,\n    // Only have one cache entry because the arg always maps to one string\n    serializeQueryArgs: ({ endpointName }) => {\n      return endpointName\n     },\n     // Always merge incoming data to the cache entry\n     merge: (currentCache, newItems) => {\n       currentCache.push(...newItems)\n     },\n     // Refetch when the page arg changes\n     forceRefetch({ currentArg, previousArg }) {\n       return currentArg !== previousArg\n     },\n   }),\n }),\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onquerystarted",children:(0,r.jsx)(n.code,{children:"onQueryStarted"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional)"})}),"\n",(0,r.jsxs)(n.p,{children:["Available to both ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/queries",children:"queries"})," and ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/mutations",children:"mutations"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A function that is called when you start each individual query or mutation. The function is called with a lifecycle api object containing properties such as ",(0,r.jsx)(n.code,{children:"queryFulfilled"}),", allowing code to be run when a query is started, when it succeeds, and when it fails (i.e. throughout the lifecycle of an individual query/mutation call)."]}),"\n",(0,r.jsxs)(n.p,{children:["Can be used in ",(0,r.jsx)(n.code,{children:"mutations"})," for ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/manual-cache-updates#optimistic-updates",children:"optimistic updates"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"lifecycle-api-properties",children:"Lifecycle API properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dispatch"})," - The dispatch method for the store."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getState"})," - A method to get the current state for the store."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extra"})," - ",(0,r.jsx)(n.code,{children:"extra"})," as provided as ",(0,r.jsx)(n.code,{children:"thunk.extraArgument"})," to the ",(0,r.jsx)(n.code,{children:"configureStore"})," ",(0,r.jsx)(n.code,{children:"getDefaultMiddleware"})," option."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"requestId"})," - A unique ID generated for the query/mutation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"queryFulfilled"})," - A Promise that will resolve with a ",(0,r.jsx)(n.code,{children:"data"})," property (the transformed query result),\nand a ",(0,r.jsx)(n.code,{children:"meta"})," property (",(0,r.jsx)(n.code,{children:"meta"})," returned by the ",(0,r.jsx)(n.code,{children:"baseQuery"}),").\nIf the query fails, this Promise will reject with the error. This allows you to ",(0,r.jsx)(n.code,{children:"await"})," for the query to finish."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getCacheEntry"})," - A function that gets the current value of the cache entry."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"updateCachedData"})," ",(0,r.jsx)(n.em,{children:"(query endpoints only)"})," - A function that accepts a 'recipe' callback specifying how to update the data for the corresponding cache at the time it is called. This uses ",(0,r.jsx)(n.code,{children:"immer"})," internally, and updates can be written 'mutably' while safely producing the next immutable state."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Mutation onQueryStarted signature" no-transpile',children:"async function onQueryStarted(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    queryFulfilled,\n    getCacheEntry,\n  }: MutationLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Query onQueryStarted signature" no-transpile',children:"async function onQueryStarted(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    queryFulfilled,\n    getCacheEntry,\n    updateCachedData, // available for query endpoints only\n  }: QueryLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="onQueryStarted query lifecycle example"',children:"// file: notificationsSlice.ts noEmit\nexport const messageCreated = (msg: string) => ({\n  type: 'notifications/messageCreated',\n  payload: msg,\n})\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { messageCreated } from './notificationsSlice'\n\nexport interface Post {\n  id: number\n  name: string\n}\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      async onQueryStarted(id, { dispatch, queryFulfilled }) {\n        // `onStart` side-effect\n        dispatch(messageCreated('Fetching post...'))\n        try {\n          const { data } = await queryFulfilled\n          // `onSuccess` side-effect\n          dispatch(messageCreated('Post received!'))\n        } catch (err) {\n          // `onError` side-effect\n          dispatch(messageCreated('Error fetching post!'))\n        }\n      },\n    }),\n  }),\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"oncacheentryadded",children:(0,r.jsx)(n.code,{children:"onCacheEntryAdded"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(optional)"})}),"\n",(0,r.jsxs)(n.p,{children:["Available to both ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/queries",children:"queries"})," and ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/mutations",children:"mutations"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A function that is called when a new cache entry is added, i.e. when a new subscription for the endpoint + query parameters combination is created. The function is called with a lifecycle api object containing properties such as ",(0,r.jsx)(n.code,{children:"cacheDataLoaded"})," & ",(0,r.jsx)(n.code,{children:"cacheDataRemoved"}),", allowing code to be run when a cache entry is added, when cache data is loaded, and when the cache entry is removed (i.e. throughout the lifecycle of a cache entry)."]}),"\n",(0,r.jsxs)(n.p,{children:["Can be used for ",(0,r.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/usage/streaming-updates",children:"streaming updates"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"cache-lifecycle-api-properties",children:"Cache Lifecycle API properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dispatch"})," - The dispatch method for the store."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getState"})," - A method to get the current state for the store."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extra"})," - ",(0,r.jsx)(n.code,{children:"extra"})," as provided as ",(0,r.jsx)(n.code,{children:"thunk.extraArgument"})," to the ",(0,r.jsx)(n.code,{children:"configureStore"})," ",(0,r.jsx)(n.code,{children:"getDefaultMiddleware"})," option."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"requestId"})," - A unique ID generated for the cache entry."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cacheEntryRemoved"})," - A Promise that allows you to wait for the point in time when the cache entry has been removed from the cache, by not being used/subscribed to any more in the application for too long or by dispatching ",(0,r.jsx)(n.code,{children:"api.util.resetApiState"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cacheDataLoaded"})," - A Promise that will resolve with the first value for this cache key. This allows you to ",(0,r.jsx)(n.code,{children:"await"})," until an actual value is in the cache.",(0,r.jsx)(n.br,{}),"\n","Note: If the cache entry is removed from the cache before any value has ever been resolved, this Promise will reject with ",(0,r.jsx)(n.code,{children:"new Error('Promise never resolved before cacheEntryRemoved.')"})," to prevent memory leaks. You can just re-throw that error (or not handle it at all) - it will be caught outside of ",(0,r.jsx)(n.code,{children:"cacheEntryAdded"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getCacheEntry"})," - A function that gets the current value of the cache entry."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"updateCachedData"})," ",(0,r.jsx)(n.em,{children:"(query endpoints only)"})," - A function that accepts a 'recipe' callback specifying how to update the data at the time it is called. This uses ",(0,r.jsx)(n.code,{children:"immer"})," internally, and updates can be written 'mutably' while safely producing the next immutable state."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Mutation onCacheEntryAdded signature" no-transpile',children:"async function onCacheEntryAdded(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    cacheEntryRemoved,\n    cacheDataLoaded,\n    getCacheEntry,\n  }: MutationCacheLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Query onCacheEntryAdded signature" no-transpile',children:"async function onCacheEntryAdded(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    cacheEntryRemoved,\n    cacheDataLoaded,\n    getCacheEntry,\n    updateCachedData, // available for query endpoints only\n  }: QueryCacheLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"return-value",children:"Return value"}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"./created-api/overview",children:'the "created Api" API reference'})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);