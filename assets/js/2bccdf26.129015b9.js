"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[1599],{9140:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var r=n(4848),i=n(8453);const a={id:"usage-with-typescript",title:"\u4e0e TypeScript \u4e00\u8d77\u4f7f\u7528",sidebar_label:"\u4e0e TypeScript \u4e00\u8d77\u4f7f\u7528",hide_title:!0},s="Usage With TypeScript",c={id:"usage/usage-with-typescript",title:"\u4e0e TypeScript \u4e00\u8d77\u4f7f\u7528",description:"&nbsp;",source:"@site/docs/usage/usage-with-typescript.md",sourceDirName:"usage",slug:"/usage/usage-with-typescript",permalink:"/redux-toolkit-zh/usage/usage-with-typescript",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usage/usage-with-typescript.md",tags:[],version:"current",frontMatter:{id:"usage-with-typescript",title:"\u4e0e TypeScript \u4e00\u8d77\u4f7f\u7528",sidebar_label:"\u4e0e TypeScript \u4e00\u8d77\u4f7f\u7528",hide_title:!0},sidebar:"docs",previous:{title:"\u4f7f\u7528\u6307\u5357",permalink:"/redux-toolkit-zh/usage/usage-guide"},next:{title:"\u4f7f\u7528 Immer \u7f16\u5199 Reducers",permalink:"/redux-toolkit-zh/usage/immer-reducers"}},o={},d=[{value:"Introduction",id:"introduction",level:2},{value:"<code>configureStore</code>",id:"configurestore",level:2},{value:"Getting the <code>State</code> type",id:"getting-the-state-type",level:3},{value:"Getting the <code>Dispatch</code> type",id:"getting-the-dispatch-type",level:3},{value:"Correct typings for the <code>Dispatch</code> type",id:"correct-typings-for-the-dispatch-type",level:3},{value:"Using <code>Tuple</code> without <code>getDefaultMiddleware</code>",id:"using-tuple-without-getdefaultmiddleware",level:4},{value:"Using the extracted <code>Dispatch</code> type with React Redux",id:"using-the-extracted-dispatch-type-with-react-redux",level:3},{value:"<code>createAction</code>",id:"createaction",level:2},{value:"Alternative to using a literally-typed <code>action.type</code>",id:"alternative-to-using-a-literally-typed-actiontype",level:3},{value:"<code>createReducer</code>",id:"createreducer",level:2},{value:"Building Type-Safe Reducer Argument Objects",id:"building-type-safe-reducer-argument-objects",level:3},{value:"Typing <code>builder.addMatcher</code>",id:"typing-builderaddmatcher",level:4},{value:"<code>createSlice</code>",id:"createslice",level:2},{value:"Defining the Initial State Type",id:"defining-the-initial-state-type",level:3},{value:"Defining Action Contents with <code>prepare</code> Callbacks",id:"defining-action-contents-with-prepare-callbacks",level:3},{value:"Generated Action Types for Slices",id:"generated-action-types-for-slices",level:3},{value:"Type safety with <code>extraReducers</code>",id:"type-safety-with-extrareducers",level:3},{value:"Payload with All Optional Fields",id:"payload-with-all-optional-fields",level:3},{value:"Typing Async Thunks Inside <code>createSlice</code>",id:"typing-async-thunks-inside-createslice",level:3},{value:"Wrapping <code>createSlice</code>",id:"wrapping-createslice",level:3},{value:"<code>createAsyncThunk</code>",id:"createasyncthunk",level:2},{value:"Basic <code>createAsyncThunk</code> Types",id:"basic-createasyncthunk-types",level:3},{value:"Typing the <code>thunkApi</code> Object",id:"typing-the-thunkapi-object",level:3},{value:"Manually Defining <code>thunkApi</code> Types",id:"manually-defining-thunkapi-types",level:4},{value:"Defining a Pre-Typed <code>createAsyncThunk</code>",id:"defining-a-pre-typed-createasyncthunk",level:3},{value:"<code>createEntityAdapter</code>",id:"createentityadapter",level:2},{value:"Using <code>createEntityAdapter</code> with <code>normalizr</code>",id:"using-createentityadapter-with-normalizr",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h1,{id:"usage-with-typescript",children:"Usage With TypeScript"}),"\n",(0,r.jsx)(t.admonition,{title:"What You'll Learn",type:"tip",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Details on how to use each Redux Toolkit API with TypeScript"}),"\n"]})}),"\n",(0,r.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(t.p,{children:"Redux Toolkit is written in TypeScript, and its API is designed to enable great integration with TypeScript applications."}),"\n",(0,r.jsx)(t.p,{children:"This page provides specific details for each of the different APIs included in Redux Toolkit and how to type them correctly with TypeScript."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsxs)(t.strong,{children:["See the ",(0,r.jsx)(t.a,{href:"/redux-toolkit-zh/tutorials/typescript",children:"TypeScript Quick Start tutorial page"})," for a brief overview of how to set up and use Redux Toolkit and React Redux to work with TypeScript"]}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["If you encounter any problems with the types that are not described on this page, please ",(0,r.jsx)(t.a,{href:"https://github.com/reduxjs/redux-toolkit/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc",children:"open an issue"})," for discussion."]})}),"\n",(0,r.jsx)(t.h2,{id:"configurestore",children:(0,r.jsx)(t.code,{children:"configureStore"})}),"\n",(0,r.jsxs)(t.p,{children:["The basics of using ",(0,r.jsx)(t.code,{children:"configureStore"})," are shown in ",(0,r.jsx)(t.a,{href:"/redux-toolkit-zh/tutorials/typescript",children:"TypeScript Quick Start tutorial page"}),". Here are some additional details that you might find useful."]}),"\n",(0,r.jsxs)(t.h3,{id:"getting-the-state-type",children:["Getting the ",(0,r.jsx)(t.code,{children:"State"})," type"]}),"\n",(0,r.jsxs)(t.p,{children:["The easiest way of getting the ",(0,r.jsx)(t.code,{children:"State"})," type is to define the root reducer in advance and extract its ",(0,r.jsx)(t.code,{children:"ReturnType"}),".\nIt is recommended to give the type a different name like ",(0,r.jsx)(t.code,{children:"RootState"})," to prevent confusion, as the type name ",(0,r.jsx)(t.code,{children:"State"})," is usually overused."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { combineReducers } from '@reduxjs/toolkit'\nconst rootReducer = combineReducers({})\n// highlight-start\nexport type RootState = ReturnType<typeof rootReducer>\n// highlight-end\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Alternatively, if you choose to not create a ",(0,r.jsx)(t.code,{children:"rootReducer"})," yourself and instead pass the slice reducers directly to ",(0,r.jsx)(t.code,{children:"configureStore()"}),", you need to slightly modify the typing to correctly infer the root reducer:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { configureStore } from '@reduxjs/toolkit'\n// ...\nconst store = configureStore({\n  reducer: {\n    one: oneSlice.reducer,\n    two: twoSlice.reducer,\n  },\n})\nexport type RootState = ReturnType<typeof store.getState>\n\nexport default store\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If you pass the reducers directly to ",(0,r.jsx)(t.code,{children:"configureStore()"})," and do not define the root reducer explicitly, there is no reference to ",(0,r.jsx)(t.code,{children:"rootReducer"}),".\nInstead, you can refer to ",(0,r.jsx)(t.code,{children:"store.getState"}),", in order to get the ",(0,r.jsx)(t.code,{children:"State"})," type."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { configureStore } from '@reduxjs/toolkit'\nimport rootReducer from './rootReducer'\nconst store = configureStore({\n  reducer: rootReducer,\n})\nexport type RootState = ReturnType<typeof store.getState>\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"getting-the-dispatch-type",children:["Getting the ",(0,r.jsx)(t.code,{children:"Dispatch"})," type"]}),"\n",(0,r.jsxs)(t.p,{children:["If you want to get the ",(0,r.jsx)(t.code,{children:"Dispatch"})," type from your store, you can extract it after creating the store. It is recommended to give the type a different name like ",(0,r.jsx)(t.code,{children:"AppDispatch"})," to prevent confusion, as the type name ",(0,r.jsx)(t.code,{children:"Dispatch"})," is usually overused. You may also find it to be more convenient to export a hook like ",(0,r.jsx)(t.code,{children:"useAppDispatch"})," shown below, then using it wherever you'd call ",(0,r.jsx)(t.code,{children:"useDispatch"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { configureStore } from '@reduxjs/toolkit'\nimport { useDispatch } from 'react-redux'\nimport rootReducer from './rootReducer'\n\nconst store = configureStore({\n  reducer: rootReducer,\n})\n\n// highlight-start\nexport type AppDispatch = typeof store.dispatch\nexport const useAppDispatch = useDispatch.withTypes<AppDispatch>() // Export a hook that can be reused to resolve types\n// highlight-end\n\nexport default store\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"correct-typings-for-the-dispatch-type",children:["Correct typings for the ",(0,r.jsx)(t.code,{children:"Dispatch"})," type"]}),"\n",(0,r.jsxs)(t.p,{children:["The type of the ",(0,r.jsx)(t.code,{children:"dispatch"})," function type will be directly inferred from the ",(0,r.jsx)(t.code,{children:"middleware"})," option. So if you add ",(0,r.jsx)(t.em,{children:"correctly typed"})," middlewares, ",(0,r.jsx)(t.code,{children:"dispatch"})," should already be correctly typed."]}),"\n",(0,r.jsxs)(t.p,{children:["As TypeScript often widens array types when combining arrays using the spread operator, we suggest using the ",(0,r.jsx)(t.code,{children:".concat(...)"})," and ",(0,r.jsx)(t.code,{children:".prepend(...)"})," methods of the ",(0,r.jsx)(t.code,{children:"Tuple"})," returned by ",(0,r.jsx)(t.code,{children:"getDefaultMiddleware()"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { configureStore } from '@reduxjs/toolkit'\nimport additionalMiddleware from 'additional-middleware'\nimport logger from 'redux-logger'\n// @ts-ignore\nimport untypedMiddleware from 'untyped-middleware'\nimport rootReducer from './rootReducer'\n\nexport type RootState = ReturnType<typeof rootReducer>\nconst store = configureStore({\n  reducer: rootReducer,\n  // highlight-start\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware()\n      .prepend(\n        // correctly typed middlewares can just be used\n        additionalMiddleware,\n        // you can also type middlewares manually\n        untypedMiddleware as Middleware<\n          (action: Action<'specialAction'>) => number,\n          RootState\n        >,\n      )\n      // prepend and concat calls can be chained\n      .concat(logger),\n  // highlight-end\n})\n\nexport type AppDispatch = typeof store.dispatch\n\nexport default store\n"})}),"\n",(0,r.jsxs)(t.h4,{id:"using-tuple-without-getdefaultmiddleware",children:["Using ",(0,r.jsx)(t.code,{children:"Tuple"})," without ",(0,r.jsx)(t.code,{children:"getDefaultMiddleware"})]}),"\n",(0,r.jsxs)(t.p,{children:["If you want to skip the usage of ",(0,r.jsx)(t.code,{children:"getDefaultMiddleware"})," altogether, you are required to use ",(0,r.jsx)(t.code,{children:"Tuple"})," for type-safe creation of your ",(0,r.jsx)(t.code,{children:"middleware"})," array. This class extends the default JavaScript ",(0,r.jsx)(t.code,{children:"Array"})," type, only with modified typings for ",(0,r.jsx)(t.code,{children:".concat(...)"})," and the additional ",(0,r.jsx)(t.code,{children:".prepend(...)"})," method."]}),"\n",(0,r.jsx)(t.p,{children:"For example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { configureStore, Tuple } from '@reduxjs/toolkit'\n\nconfigureStore({\n  reducer: rootReducer,\n  middleware: () => new Tuple(additionalMiddleware, logger),\n})\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"using-the-extracted-dispatch-type-with-react-redux",children:["Using the extracted ",(0,r.jsx)(t.code,{children:"Dispatch"})," type with React Redux"]}),"\n",(0,r.jsxs)(t.p,{children:["By default, the React Redux ",(0,r.jsx)(t.code,{children:"useDispatch"})," hook does not contain any types that take middlewares into account. If you need a more specific type for the ",(0,r.jsx)(t.code,{children:"dispatch"})," function when dispatching, you may specify the type of the returned ",(0,r.jsx)(t.code,{children:"dispatch"})," function, or create a custom-typed version of ",(0,r.jsx)(t.code,{children:"useSelector"}),". See ",(0,r.jsx)(t.a,{href:"https://react-redux.js.org/using-react-redux/static-typing#typing-the-usedispatch-hook",children:"the React Redux documentation"})," for details."]}),"\n",(0,r.jsx)(t.h2,{id:"createaction",children:(0,r.jsx)(t.code,{children:"createAction"})}),"\n",(0,r.jsxs)(t.p,{children:["For most use cases, there is no need to have a literal definition of ",(0,r.jsx)(t.code,{children:"action.type"}),", so the following can be used:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"createAction<number>('test')\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This will result in the created action being of type ",(0,r.jsx)(t.code,{children:"PayloadActionCreator<number, string>"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["In some setups, you will need a literal type for ",(0,r.jsx)(t.code,{children:"action.type"}),", though.\nUnfortunately, TypeScript type definitions do not allow for a mix of manually-defined and inferred type parameters, so you'll have to specify the ",(0,r.jsx)(t.code,{children:"type"})," both in the Generic definition as well as in the actual JavaScript code:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"createAction<number, 'test'>('test')\n"})}),"\n",(0,r.jsx)(t.p,{children:"If you are looking for an alternate way of writing this without the duplication, you can use a prepare callback so that both type parameters can be inferred from arguments, removing the need to specify the action type."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"function withPayloadType<T>() {\n  return (t: T) => ({ payload: t })\n}\ncreateAction('test', withPayloadType<string>())\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"alternative-to-using-a-literally-typed-actiontype",children:["Alternative to using a literally-typed ",(0,r.jsx)(t.code,{children:"action.type"})]}),"\n",(0,r.jsxs)(t.p,{children:["If you are using ",(0,r.jsx)(t.code,{children:"action.type"})," as a discriminator on a discriminated union, for example to correctly type your payload in ",(0,r.jsx)(t.code,{children:"case"})," statements, you might be interested in this alternative:"]}),"\n",(0,r.jsxs)(t.p,{children:["Created action creators have a ",(0,r.jsx)(t.code,{children:"match"})," method that acts as a ",(0,r.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates",children:"type predicate"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"const increment = createAction<number>('increment')\nfunction test(action: Action) {\n  if (increment.match(action)) {\n    // action.payload inferred correctly here\n    action.payload\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This ",(0,r.jsx)(t.code,{children:"match"})," method is also very useful in combination with ",(0,r.jsx)(t.code,{children:"redux-observable"})," and RxJS's ",(0,r.jsx)(t.code,{children:"filter"})," method."]}),"\n",(0,r.jsx)(t.h2,{id:"createreducer",children:(0,r.jsx)(t.code,{children:"createReducer"})}),"\n",(0,r.jsx)(t.h3,{id:"building-type-safe-reducer-argument-objects",children:"Building Type-Safe Reducer Argument Objects"}),"\n",(0,r.jsxs)(t.p,{children:["The second parameter for ",(0,r.jsx)(t.code,{children:"createReducer"})," is a callback that receives a ",(0,r.jsx)(t.code,{children:"ActionReducerMapBuilder"})," instance:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",metastring:"{3-10}",children:"const increment = createAction<number, 'increment'>('increment')\nconst decrement = createAction<number, 'decrement'>('decrement')\ncreateReducer(0, (builder) =>\n  builder\n    .addCase(increment, (state, action) => {\n      // action is inferred correctly here\n    })\n    .addCase(decrement, (state, action: PayloadAction<string>) => {\n      // this would error out\n    }),\n)\n"})}),"\n",(0,r.jsxs)(t.h4,{id:"typing-builderaddmatcher",children:["Typing ",(0,r.jsx)(t.code,{children:"builder.addMatcher"})]}),"\n",(0,r.jsxs)(t.p,{children:["As the first ",(0,r.jsx)(t.code,{children:"matcher"})," argument to ",(0,r.jsx)(t.code,{children:"builder.addMatcher"}),", a ",(0,r.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates",children:"type predicate"})," function should be used.\nAs a result, the ",(0,r.jsx)(t.code,{children:"action"})," argument for the second ",(0,r.jsx)(t.code,{children:"reducer"})," argument can be inferred by TypeScript:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"function isNumberValueAction(action: UnknownAction): action is PayloadAction<{ value: number }> {\n  return typeof action.payload.value === 'number'\n}\n\ncreateReducer({ value: 0 }, builder =>\n   builder.addMatcher(isNumberValueAction, (state, action) => {\n      state.value += action.payload.value\n   })\n})\n"})}),"\n",(0,r.jsx)(t.h2,{id:"createslice",children:(0,r.jsx)(t.code,{children:"createSlice"})}),"\n",(0,r.jsxs)(t.p,{children:["As ",(0,r.jsx)(t.code,{children:"createSlice"})," creates your actions as well as your reducer for you, you don't have to worry about type safety here.\nAction types can just be provided inline:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"const slice = createSlice({\n  name: 'test',\n  initialState: 0,\n  reducers: {\n    increment: (state, action: PayloadAction<number>) => state + action.payload,\n  },\n})\n// now available:\nslice.actions.increment(2)\n// also available:\nslice.caseReducers.increment(0, { type: 'increment', payload: 5 })\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If you have too many case reducers and defining them inline would be messy, or you want to reuse case reducers across slices, you can also define them outside the ",(0,r.jsx)(t.code,{children:"createSlice"})," call and type them as ",(0,r.jsx)(t.code,{children:"CaseReducer"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"type State = number\nconst increment: CaseReducer<State, PayloadAction<number>> = (state, action) =>\n  state + action.payload\n\ncreateSlice({\n  name: 'test',\n  initialState: 0,\n  reducers: {\n    increment,\n  },\n})\n"})}),"\n",(0,r.jsx)(t.h3,{id:"defining-the-initial-state-type",children:"Defining the Initial State Type"}),"\n",(0,r.jsxs)(t.p,{children:["You might have noticed that it is not a good idea to pass your ",(0,r.jsx)(t.code,{children:"SliceState"})," type as a generic to ",(0,r.jsx)(t.code,{children:"createSlice"}),". This is due to the fact that in almost all cases, follow-up generic parameters to ",(0,r.jsx)(t.code,{children:"createSlice"}),' need to be inferred, and TypeScript cannot mix explicit declaration and inference of generic types within the same "generic block".']}),"\n",(0,r.jsxs)(t.p,{children:["The standard approach is to declare an interface or type for your state, create an initial state value that uses that type, and pass the initial state value to ",(0,r.jsx)(t.code,{children:"createSlice"}),". You can also use the construct ",(0,r.jsx)(t.code,{children:"initialState: myInitialState satisfies SliceState as SliceState"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"{1,4,8,15}",children:"type SliceState = { state: 'loading' } | { state: 'finished'; data: string }\n\n// First approach: define the initial state using that type\nconst initialState: SliceState = { state: 'loading' }\n\ncreateSlice({\n  name: 'test1',\n  initialState, // type SliceState is inferred for the state of the slice\n  reducers: {},\n})\n\n// Or, cast the initial state as necessary\ncreateSlice({\n  name: 'test2',\n  initialState: { state: 'loading' } satisfies SliceState as SliceState,\n  reducers: {},\n})\n"})}),"\n",(0,r.jsxs)(t.p,{children:["which will result in a ",(0,r.jsx)(t.code,{children:"Slice<SliceState, ...>"}),"."]}),"\n",(0,r.jsxs)(t.h3,{id:"defining-action-contents-with-prepare-callbacks",children:["Defining Action Contents with ",(0,r.jsx)(t.code,{children:"prepare"})," Callbacks"]}),"\n",(0,r.jsxs)(t.p,{children:["If you want to add a ",(0,r.jsx)(t.code,{children:"meta"})," or ",(0,r.jsx)(t.code,{children:"error"})," property to your action, or customize the ",(0,r.jsx)(t.code,{children:"payload"})," of your action, you have to use the ",(0,r.jsx)(t.code,{children:"prepare"})," notation."]}),"\n",(0,r.jsx)(t.p,{children:"Using this notation with TypeScript looks like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"{5-16}",children:"const blogSlice = createSlice({\n  name: 'blogData',\n  initialState,\n  reducers: {\n    receivedAll: {\n      reducer(\n        state,\n        action: PayloadAction<Page[], string, { currentPage: number }>,\n      ) {\n        state.all = action.payload\n        state.meta = action.meta\n      },\n      prepare(payload: Page[], currentPage: number) {\n        return { payload, meta: { currentPage } }\n      },\n    },\n  },\n})\n"})}),"\n",(0,r.jsx)(t.h3,{id:"generated-action-types-for-slices",children:"Generated Action Types for Slices"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"createSlice"})," generates action type strings by combining the ",(0,r.jsx)(t.code,{children:"name"})," field from the slice with the field name of the reducer function, like ",(0,r.jsx)(t.code,{children:"'test/increment'"}),". This is strongly typed as the exact value, thanks to TS's string literal analysis."]}),"\n",(0,r.jsxs)(t.p,{children:["You can also use the ",(0,r.jsx)(t.code,{children:"slice.action.myAction.match"})," ",(0,r.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates",children:"type predicate"}),", which will narrow down an action object to the exact type:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"{10}",children:"const slice = createSlice({\n  name: 'test',\n  initialState: 0,\n  reducers: {\n    increment: (state, action: PayloadAction<number>) => state + action.payload,\n  },\n})\n\ntype incrementType = typeof slice.actions.increment.type\n// type incrementType = 'test/increment'\n\nfunction myCustomMiddleware(action: Action) {\n  if (slice.actions.increment.match(action)) {\n    // `action` is narrowed down to the type `PayloadAction<number>` here.\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If you actually ",(0,r.jsx)(t.em,{children:"need"})," that type, unfortunately there is no other way than manual casting."]}),"\n",(0,r.jsxs)(t.h3,{id:"type-safety-with-extrareducers",children:["Type safety with ",(0,r.jsx)(t.code,{children:"extraReducers"})]}),"\n",(0,r.jsxs)(t.p,{children:["Reducer lookup tables that map an action ",(0,r.jsx)(t.code,{children:"type"})," string to a reducer function are not easy to fully type correctly. This affects both ",(0,r.jsx)(t.code,{children:"createReducer"})," and the ",(0,r.jsx)(t.code,{children:"extraReducers"})," argument for ",(0,r.jsx)(t.code,{children:"createSlice"}),". So, like with ",(0,r.jsx)(t.code,{children:"createReducer"}),", ",(0,r.jsx)(t.a,{href:"#building-type-safe-reducer-argument-objects",children:'you should use the "builder callback" approach'})," for defining the reducer object argument."]}),"\n",(0,r.jsxs)(t.p,{children:["This is particularly useful when a slice reducer needs to handle action types generated by other slices, or generated by specific calls to ",(0,r.jsx)(t.code,{children:"createAction"})," (such as the actions generated by ",(0,r.jsx)(t.a,{href:"/redux-toolkit-zh/api/createAsyncThunk",children:(0,r.jsx)(t.code,{children:"createAsyncThunk"})}),")."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"{27-30}",children:"const fetchUserById = createAsyncThunk(\n  'users/fetchById',\n  // if you type your function argument here\n  async (userId: number) => {\n    const response = await fetch(`https://reqres.in/api/users/${userId}`)\n    return (await response.json()) as Returned\n  },\n)\n\ninterface UsersState {\n  entities: User[]\n  loading: 'idle' | 'pending' | 'succeeded' | 'failed'\n}\n\nconst initialState = {\n  entities: [],\n  loading: 'idle',\n} satisfies UsersState as UsersState\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {\n    // fill in primary logic here\n  },\n  extraReducers: (builder) => {\n    builder.addCase(fetchUserById.pending, (state, action) => {\n      // both `state` and `action` are now correctly typed\n      // based on the slice state and the `pending` action creator\n    })\n  },\n})\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Like the ",(0,r.jsx)(t.code,{children:"builder"})," in ",(0,r.jsx)(t.code,{children:"createReducer"}),", this ",(0,r.jsx)(t.code,{children:"builder"})," also accepts ",(0,r.jsx)(t.code,{children:"addMatcher"})," (see ",(0,r.jsxs)(t.a,{href:"#typing-builderaddmatcher",children:["typing ",(0,r.jsx)(t.code,{children:"builder.matcher"})]}),") and ",(0,r.jsx)(t.code,{children:"addDefaultCase"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"payload-with-all-optional-fields",children:"Payload with All Optional Fields"}),"\n",(0,r.jsxs)(t.p,{children:["If you try to supply a payload type where all fields are optional, like ",(0,r.jsx)(t.code,{children:"PayloadAction<Partial<User>>"})," or ",(0,r.jsx)(t.code,{children:"PayloadAction<{value?: string}>"}),", TS may not be able to infer the action type correctly."]}),"\n",(0,r.jsxs)(t.p,{children:["You can work around this by ",(0,r.jsxs)(t.a,{href:"https://github.com/reduxjs/redux-toolkit/issues/1423#issuecomment-902680573",children:["using a custom ",(0,r.jsx)(t.code,{children:"AtLeastOne"})," utility type"]})," to help ensure that at least one of the fields must be passed in:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"type AtLeastOne<T extends Record<string, any>> = keyof T extends infer K\n  ? K extends string\n    ? Pick<T, K & keyof T> & Partial<T>\n    : never\n  : never\n\n// Use this type instead of `Partial<MyPayloadType>`\ntype AtLeastOneUserField = AtLeastOne<User>\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"typing-async-thunks-inside-createslice",children:["Typing Async Thunks Inside ",(0,r.jsx)(t.code,{children:"createSlice"})]}),"\n",(0,r.jsxs)(t.p,{children:["As of 2.0, ",(0,r.jsx)(t.code,{children:"createSlice"})," allows ",(0,r.jsxs)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(153).A+"#the-reducers-creator-callback-notation",children:["defining thunks inside of ",(0,r.jsx)(t.code,{children:"reducers"})," using a callback syntax"]}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Typing for the ",(0,r.jsx)(t.code,{children:"create.asyncThunk"})," method works in the same way as ",(0,r.jsx)(t.a,{href:"#createasyncthunk",children:(0,r.jsx)(t.code,{children:"createAsyncThunk"})}),", with one key difference."]}),"\n",(0,r.jsxs)(t.p,{children:["A type for ",(0,r.jsx)(t.code,{children:"state"})," and/or ",(0,r.jsx)(t.code,{children:"dispatch"})," ",(0,r.jsx)(t.em,{children:"cannot"})," be provided as part of the ",(0,r.jsx)(t.code,{children:"ThunkApiConfig"}),", as this would cause circular types."]}),"\n",(0,r.jsxs)(t.p,{children:["Instead, it is necessary to assert the type when needed - ",(0,r.jsx)(t.code,{children:"getState() as RootState"}),". You may also include an explicit return type for the payload function as well, in order to break the circular type inference cycle."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"create.asyncThunk<Todo, string, { rejectValue: { error: string } }>(\n  // highlight-start\n  // may need to include an explicit return type\n  async (id: string, thunkApi): Promise<Todo> => {\n    // Cast types for `getState` and `dispatch` manually\n    const state = thunkApi.getState() as RootState\n    const dispatch = thunkApi.dispatch as AppDispatch\n    // highlight-end\n    try {\n      const todo = await fetchTodo()\n      return todo\n    } catch (e) {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no!',\n      })\n    }\n  },\n)\n"})}),"\n",(0,r.jsxs)(t.p,{children:["For common thunk API configuration options, a ",(0,r.jsxs)(t.a,{href:"../usage/usage-with-typescript#defining-a-pre-typed-createasyncthunk",children:[(0,r.jsx)(t.code,{children:"withTypes"})," helper"]})," is provided:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"reducers: (create) => {\n  const createAThunk = create.asyncThunk.withTypes<{\n    rejectValue: { error: string }\n  }>()\n\n  return {\n    fetchTodo: createAThunk<Todo, string>(async (id, thunkApi) => {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no!',\n      })\n    }),\n    fetchTodos: createAThunk<Todo[], string>(async (id, thunkApi) => {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no, not again!',\n      })\n    }),\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"wrapping-createslice",children:["Wrapping ",(0,r.jsx)(t.code,{children:"createSlice"})]}),"\n",(0,r.jsxs)(t.p,{children:["If you need to reuse reducer logic, it is common to write ",(0,r.jsx)(t.a,{href:"https://redux.js.org/recipes/structuring-reducers/reusing-reducer-logic#customizing-behavior-with-higher-order-reducers",children:'"higher-order reducers"'})," that wrap a reducer function with additional common behavior. This can be done with ",(0,r.jsx)(t.code,{children:"createSlice"})," as well, but due to the complexity of the types for ",(0,r.jsx)(t.code,{children:"createSlice"}),", you have to use the ",(0,r.jsx)(t.code,{children:"SliceCaseReducers"})," and ",(0,r.jsx)(t.code,{children:"ValidateSliceCaseReducers"})," types in a very specific way."]}),"\n",(0,r.jsxs)(t.p,{children:['Here is an example of such a "generic" wrapped ',(0,r.jsx)(t.code,{children:"createSlice"})," call:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"interface GenericState<T> {\n  data?: T\n  status: 'loading' | 'finished' | 'error'\n}\n\nconst createGenericSlice = <\n  T,\n  Reducers extends SliceCaseReducers<GenericState<T>>,\n>({\n  name = '',\n  initialState,\n  reducers,\n}: {\n  name: string\n  initialState: GenericState<T>\n  reducers: ValidateSliceCaseReducers<GenericState<T>, Reducers>\n}) => {\n  return createSlice({\n    name,\n    initialState,\n    reducers: {\n      start(state) {\n        state.status = 'loading'\n      },\n      /**\n       * If you want to write to values of the state that depend on the generic\n       * (in this case: `state.data`, which is T), you might need to specify the\n       * State type manually here, as it defaults to `Draft<GenericState<T>>`,\n       * which can sometimes be problematic with yet-unresolved generics.\n       * This is a general problem when working with immer's Draft type and generics.\n       */\n      success(state: GenericState<T>, action: PayloadAction<T>) {\n        state.data = action.payload\n        state.status = 'finished'\n      },\n      ...reducers,\n    },\n  })\n}\n\nconst wrappedSlice = createGenericSlice({\n  name: 'test',\n  initialState: { status: 'loading' } as GenericState<string>,\n  reducers: {\n    magic(state) {\n      state.status = 'finished'\n      state.data = 'hocus pocus'\n    },\n  },\n})\n"})}),"\n",(0,r.jsx)(t.h2,{id:"createasyncthunk",children:(0,r.jsx)(t.code,{children:"createAsyncThunk"})}),"\n",(0,r.jsxs)(t.h3,{id:"basic-createasyncthunk-types",children:["Basic ",(0,r.jsx)(t.code,{children:"createAsyncThunk"})," Types"]}),"\n",(0,r.jsxs)(t.p,{children:["In the most common use cases, you should not need to explicitly declare any types for the ",(0,r.jsx)(t.code,{children:"createAsyncThunk"})," call itself."]}),"\n",(0,r.jsxs)(t.p,{children:["Just provide a type for the first argument to the ",(0,r.jsx)(t.code,{children:"payloadCreator"})," argument as you would for any function argument, and the resulting thunk will accept the same type as its input parameter.\nThe return type of the ",(0,r.jsx)(t.code,{children:"payloadCreator"})," will also be reflected in all generated action types."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'interface MyData {\n  // ...\n}\n\nconst fetchUserById = createAsyncThunk(\n  \'users/fetchById\',\n  // highlight-start\n  // Declare the type your function argument here:\n  async (userId: number) => {\n    // highlight-end\n    const response = await fetch(`https://reqres.in/api/users/${userId}`)\n    // Inferred return type: Promise<MyData>\n    // highlight-next-line\n    return (await response.json()) as MyData\n  },\n)\n\n// the parameter of `fetchUserById` is automatically inferred to `number` here\n// and dispatching the resulting thunkAction will return a Promise of a correctly\n// typed "fulfilled" or "rejected" action.\nconst lastReturnedAction = await store.dispatch(fetchUserById(3))\n'})}),"\n",(0,r.jsxs)(t.h3,{id:"typing-the-thunkapi-object",children:["Typing the ",(0,r.jsx)(t.code,{children:"thunkApi"})," Object"]}),"\n",(0,r.jsxs)(t.p,{children:["The second argument to the ",(0,r.jsx)(t.code,{children:"payloadCreator"}),", known as ",(0,r.jsx)(t.code,{children:"thunkApi"}),", is an object containing references to the ",(0,r.jsx)(t.code,{children:"dispatch"}),", ",(0,r.jsx)(t.code,{children:"getState"}),", and ",(0,r.jsx)(t.code,{children:"extra"})," arguments from the thunk middleware as well as a utility function called ",(0,r.jsx)(t.code,{children:"rejectWithValue"}),". If you want to use these from within the ",(0,r.jsx)(t.code,{children:"payloadCreator"}),", you will need to define some generic arguments, as the types for these arguments cannot be inferred. Also, as TS cannot mix explicit and inferred generic parameters, from this point on you'll have to define the ",(0,r.jsx)(t.code,{children:"Returned"})," and ",(0,r.jsx)(t.code,{children:"ThunkArg"})," generic parameter as well."]}),"\n",(0,r.jsxs)(t.h4,{id:"manually-defining-thunkapi-types",children:["Manually Defining ",(0,r.jsx)(t.code,{children:"thunkApi"})," Types"]}),"\n",(0,r.jsx)(t.p,{children:"To define the types for these arguments, pass an object as the third generic argument, with type declarations for some or all of these fields:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"type AsyncThunkConfig = {\n  /** return type for `thunkApi.getState` */\n  state?: unknown\n  /** type for `thunkApi.dispatch` */\n  dispatch?: Dispatch\n  /** type of the `extra` argument for the thunk middleware, which will be passed in as `thunkApi.extra` */\n  extra?: unknown\n  /** type to be passed into `rejectWithValue`'s first argument that will end up on `rejectedAction.payload` */\n  rejectValue?: unknown\n  /** return type of the `serializeError` option callback */\n  serializedErrorType?: unknown\n  /** type to be returned from the `getPendingMeta` option callback & merged into `pendingAction.meta` */\n  pendingMeta?: unknown\n  /** type to be passed into the second argument of `fulfillWithValue` to finally be merged into `fulfilledAction.meta` */\n  fulfilledMeta?: unknown\n  /** type to be passed into the second argument of `rejectWithValue` to finally be merged into `rejectedAction.meta` */\n  rejectedMeta?: unknown\n}\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"const fetchUserById = createAsyncThunk<\n  // highlight-start\n  // Return type of the payload creator\n  MyData,\n  // First argument to the payload creator\n  number,\n  {\n    // Optional fields for defining thunkApi field types\n    dispatch: AppDispatch\n    state: State\n    extra: {\n      jwt: string\n    }\n  }\n  // highlight-end\n>('users/fetchById', async (userId, thunkApi) => {\n  const response = await fetch(`https://reqres.in/api/users/${userId}`, {\n    headers: {\n      Authorization: `Bearer ${thunkApi.extra.jwt}`,\n    },\n  })\n  return (await response.json()) as MyData\n})\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If you are performing a request that you know will typically either be a success or have an expected error format, you can pass in a type to ",(0,r.jsx)(t.code,{children:"rejectValue"})," and ",(0,r.jsx)(t.code,{children:"return rejectWithValue(knownPayload)"})," in the action creator. This allows you to reference the error payload in the reducer as well as in a component after dispatching the ",(0,r.jsx)(t.code,{children:"createAsyncThunk"})," action."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"interface MyKnownError {\n  errorMessage: string\n  // ...\n}\ninterface UserAttributes {\n  id: string\n  first_name: string\n  last_name: string\n  email: string\n}\n\nconst updateUser = createAsyncThunk<\n  // Return type of the payload creator\n  MyData,\n  // First argument to the payload creator\n  UserAttributes,\n  // Types for ThunkAPI\n  {\n    extra: {\n      jwt: string\n    }\n    rejectValue: MyKnownError\n  }\n>('users/update', async (user, thunkApi) => {\n  const { id, ...userData } = user\n  const response = await fetch(`https://reqres.in/api/users/${id}`, {\n    method: 'PUT',\n    headers: {\n      Authorization: `Bearer ${thunkApi.extra.jwt}`,\n    },\n    body: JSON.stringify(userData),\n  })\n  if (response.status === 400) {\n    // Return the known error for future handling\n    return thunkApi.rejectWithValue((await response.json()) as MyKnownError)\n  }\n  return (await response.json()) as MyData\n})\n"})}),"\n",(0,r.jsxs)(t.p,{children:["While this notation for ",(0,r.jsx)(t.code,{children:"state"}),", ",(0,r.jsx)(t.code,{children:"dispatch"}),", ",(0,r.jsx)(t.code,{children:"extra"})," and ",(0,r.jsx)(t.code,{children:"rejectValue"})," might seem uncommon at first, it allows you to provide only the types for these you actually need - so for example, if you are not accessing ",(0,r.jsx)(t.code,{children:"getState"})," within your ",(0,r.jsx)(t.code,{children:"payloadCreator"}),", there is no need to provide a type for ",(0,r.jsx)(t.code,{children:"state"}),". The same can be said about ",(0,r.jsx)(t.code,{children:"rejectValue"})," - if you don't need to access any potential error payload, you can ignore it."]}),"\n",(0,r.jsxs)(t.p,{children:["In addition, you can leverage checks against ",(0,r.jsx)(t.code,{children:"action.payload"})," and ",(0,r.jsx)(t.code,{children:"match"})," as provided by ",(0,r.jsx)(t.code,{children:"createAction"})," as a type-guard for when you want to access known properties on defined types. Example:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"In a reducer"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"const usersSlice = createSlice({\n  name: 'users',\n  initialState: {\n    entities: {},\n    error: null,\n  },\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(updateUser.fulfilled, (state, { payload }) => {\n      state.entities[payload.id] = payload\n    })\n    builder.addCase(updateUser.rejected, (state, action) => {\n      if (action.payload) {\n        // Since we passed in `MyKnownError` to `rejectValue` in `updateUser`, the type information will be available here.\n        state.error = action.payload.errorMessage\n      } else {\n        state.error = action.error\n      }\n    })\n  },\n})\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"In a component"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"const handleUpdateUser = async (userData) => {\n  const resultAction = await dispatch(updateUser(userData))\n  if (updateUser.fulfilled.match(resultAction)) {\n    const user = resultAction.payload\n    showToast('success', `Updated ${user.name}`)\n  } else {\n    if (resultAction.payload) {\n      // Since we passed in `MyKnownError` to `rejectValue` in `updateUser`, the type information will be available here.\n      // Note: this would also be a good place to do any handling that relies on the `rejectedWithValue` payload, such as setting field errors\n      showToast('error', `Update failed: ${resultAction.payload.errorMessage}`)\n    } else {\n      showToast('error', `Update failed: ${resultAction.error.message}`)\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"defining-a-pre-typed-createasyncthunk",children:["Defining a Pre-Typed ",(0,r.jsx)(t.code,{children:"createAsyncThunk"})]}),"\n",(0,r.jsxs)(t.p,{children:['As of RTK 1.9, you can define a "pre-typed" version of ',(0,r.jsx)(t.code,{children:"createAsyncThunk"})," that can have the types for ",(0,r.jsx)(t.code,{children:"state"}),", ",(0,r.jsx)(t.code,{children:"dispatch"}),", and ",(0,r.jsx)(t.code,{children:"extra"})," built in. This lets you set up those types once, so you don't have to repeat them each time you call ",(0,r.jsx)(t.code,{children:"createAsyncThunk"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["To do this, call ",(0,r.jsx)(t.code,{children:"createAsyncThunk.withTypes<>()"}),", and pass in an object containing the field names and types for any of the fields in the ",(0,r.jsx)(t.code,{children:"AsyncThunkConfig"})," type listed above. This might look like:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"const createAppAsyncThunk = createAsyncThunk.withTypes<{\n  state: RootState\n  dispatch: AppDispatch\n  rejectValue: string\n  extra: { s: string; n: number }\n}>()\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Import and use that pre-typed ",(0,r.jsx)(t.code,{children:"createAppAsyncThunk"})," instead of the original, and the types will be used automatically."]}),"\n",(0,r.jsx)(t.h2,{id:"createentityadapter",children:(0,r.jsx)(t.code,{children:"createEntityAdapter"})}),"\n",(0,r.jsxs)(t.p,{children:["Typing ",(0,r.jsx)(t.code,{children:"createEntityAdapter"})," only requires you to specify the entity type as the single generic argument."]}),"\n",(0,r.jsxs)(t.p,{children:["The example from the ",(0,r.jsx)(t.code,{children:"createEntityAdapter"})," documentation would look like this in TypeScript:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"interface Book {\n  bookId: number\n  title: string\n  // ...\n}\n\n// highlight-next-line\nconst booksAdapter = createEntityAdapter<Book>({\n  selectId: (book) => book.bookId,\n  sortComparer: (a, b) => a.title.localeCompare(b.title),\n})\n\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState: booksAdapter.getInitialState(),\n  reducers: {\n    bookAdded: booksAdapter.addOne,\n    booksReceived(state, action: PayloadAction<{ books: Book[] }>) {\n      booksAdapter.setAll(state, action.payload.books)\n    },\n  },\n})\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"using-createentityadapter-with-normalizr",children:["Using ",(0,r.jsx)(t.code,{children:"createEntityAdapter"})," with ",(0,r.jsx)(t.code,{children:"normalizr"})]}),"\n",(0,r.jsxs)(t.p,{children:["When using a library like ",(0,r.jsx)(t.a,{href:"https://github.com/paularmstrong/normalizr/",children:(0,r.jsx)(t.code,{children:"normalizr"})}),", your normalized data will resemble this shape:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"{\n  result: 1,\n  entities: {\n    1: { id: 1, other: 'property' },\n    2: { id: 2, other: 'property' }\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The methods ",(0,r.jsx)(t.code,{children:"addMany"}),", ",(0,r.jsx)(t.code,{children:"upsertMany"}),", and ",(0,r.jsx)(t.code,{children:"setAll"})," all allow you to pass in the ",(0,r.jsx)(t.code,{children:"entities"})," portion of this directly with no extra conversion steps. However, the ",(0,r.jsx)(t.code,{children:"normalizr"})," TS typings currently do not correctly reflect that multiple data types may be included in the results, so you will need to specify that type structure yourself."]}),"\n",(0,r.jsx)(t.p,{children:"Here is an example of how that would look:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"type Author = { id: number; name: string }\ntype Article = { id: number; title: string }\ntype Comment = { id: number; commenter: number }\n\nexport const fetchArticle = createAsyncThunk(\n  'articles/fetchArticle',\n  async (id: number) => {\n    const data = await fakeAPI.articles.show(id)\n    // Normalize the data so reducers can responded to a predictable payload.\n    // Note: at the time of writing, normalizr does not automatically infer the result,\n    // so we explicitly declare the shape of the returned normalized data as a generic arg.\n    const normalized = normalize<\n      any,\n      {\n        articles: { [key: string]: Article }\n        users: { [key: string]: Author }\n        comments: { [key: string]: Comment }\n      }\n    >(data, articleEntity)\n    return normalized.entities\n  },\n)\n\nexport const slice = createSlice({\n  name: 'articles',\n  initialState: articlesAdapter.getInitialState(),\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchArticle.fulfilled, (state, action) => {\n      // The type signature on action.payload matches what we passed into the generic for `normalize`, allowing us to access specific properties on `payload.articles` if desired\n      articlesAdapter.upsertMany(state, action.payload.articles)\n    })\n  },\n})\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},153:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/files/createSlice-64187a6a84588af96f1f1bcfc9d1d79e.mdx"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var r=n(6540);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);