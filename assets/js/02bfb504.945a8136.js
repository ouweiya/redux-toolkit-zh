"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[5034],{8403:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var n=a(4848),i=a(8453);const s={id:"manual-cache-updates",title:"\u624b\u52a8\u7f13\u5b58\u66f4\u65b0",sidebar_label:"\u624b\u52a8\u7f13\u5b58\u66f4\u65b0",hide_title:!0,description:"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually"},r="Manual Cache Updates",c={id:"rtk-query/usage/manual-cache-updates",title:"\u624b\u52a8\u7f13\u5b58\u66f4\u65b0",description:"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually",source:"@site/docs/rtk-query/usage/manual-cache-updates.mdx",sourceDirName:"rtk-query/usage",slug:"/rtk-query/usage/manual-cache-updates",permalink:"/redux-toolkit-zh/rtk-query/usage/manual-cache-updates",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rtk-query/usage/manual-cache-updates.mdx",tags:[],version:"current",frontMatter:{id:"manual-cache-updates",title:"\u624b\u52a8\u7f13\u5b58\u66f4\u65b0",sidebar_label:"\u624b\u52a8\u7f13\u5b58\u66f4\u65b0",hide_title:!0,description:"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually"},sidebar:"docs",previous:{title:"\u81ea\u52a8\u91cd\u65b0\u83b7\u53d6",permalink:"/redux-toolkit-zh/rtk-query/usage/automated-refetching"},next:{title:"\u6761\u4ef6\u83b7\u53d6",permalink:"/redux-toolkit-zh/rtk-query/usage/conditional-fetching"}},d={},o=[{value:"Overview",id:"overview",level:2},{value:"Updating existing cache entries",id:"updating-existing-cache-entries",level:3},{value:"Creating new cache entries or replacing existing ones",id:"creating-new-cache-entries-or-replacing-existing-ones",level:3},{value:"Recipes",id:"recipes",level:2},{value:"Optimistic Updates",id:"optimistic-updates",level:3},{value:"Example",id:"example",level:4},{value:"Pessimistic Updates",id:"pessimistic-updates",level:3},{value:"General Updates",id:"general-updates",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"\xa0"}),"\n",(0,n.jsx)(t.h1,{id:"manual-cache-updates",children:"Manual Cache Updates"}),"\n",(0,n.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsxs)(t.p,{children:["For most cases, in order to receive up to date data after a triggering a change in the backend, you can take advantage of cache tag invalidation to perform ",(0,n.jsx)(t.a,{href:"./automated-refetching",children:"automated re-fetching"}),". This will cause a query to re-fetch its data when it has been told that a mutation has occurred which would cause its data to become out of date."]}),"\n",(0,n.jsx)(t.p,{children:"We recommend using automated re-fetching as a preference over manual cache updates in most situations."}),"\n",(0,n.jsxs)(t.p,{children:["However, there ",(0,n.jsx)(t.em,{children:"are"}),' use cases when manual cache updates are necessary, such as "optimistic" or "pessimistic" updates, or modifying data as part of cache entry lifecycles.']}),"\n",(0,n.jsxs)(t.p,{children:["RTK Query exports thunks for these use cases, attached to ",(0,n.jsx)(t.code,{children:"api.utils"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/api-slice-utils#updatequerydata",children:(0,n.jsx)(t.code,{children:"updateQueryData"})}),": updates an already existing cache entry"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/api-slice-utils#upsertquerydata",children:(0,n.jsx)(t.code,{children:"upsertQueryData"})}),": creates or replaces cache entries"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Since these are thunks, you can dispatch them anywhere you have access to ",(0,n.jsx)(t.code,{children:"dispatch"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"updating-existing-cache-entries",children:"Updating existing cache entries"}),"\n",(0,n.jsxs)(t.p,{children:["For updates of existing cache entries, use ",(0,n.jsx)(t.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/api-slice-utils#updatequerydata",children:(0,n.jsx)(t.code,{children:"updateQueryData"})}),"."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"updateQueryData"})," is strictly intended to perform ",(0,n.jsx)(t.em,{children:"updates"})," to existing cache entries, not create new entries. If an ",(0,n.jsx)(t.code,{children:"updateQueryData"})," thunk action is dispatched and the ",(0,n.jsx)(t.code,{children:"endpointName"})," + ",(0,n.jsx)(t.code,{children:"args"})," combination that does not match any existing cache entry, the provided ",(0,n.jsx)(t.code,{children:"recipe"})," callback will not be called, and no ",(0,n.jsx)(t.code,{children:"patches"})," or ",(0,n.jsx)(t.code,{children:"inversePatches"})," will be returned."]}),"\n",(0,n.jsx)(t.p,{children:"Use cases for manual update of cache entries:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Providing immediate feedback to the user when a mutation is attempted"}),"\n",(0,n.jsx)(t.li,{children:"After a mutation, updating a single item in a large list of items that is already cached, rather than re-fetching the whole list"}),"\n",(0,n.jsx)(t.li,{children:"Debouncing a large number of mutations with immediate feedback as though they are being applied, followed by a single request sent to the server to update the debounced attempts"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"creating-new-cache-entries-or-replacing-existing-ones",children:"Creating new cache entries or replacing existing ones"}),"\n",(0,n.jsxs)(t.p,{children:["To create or replace existing cache entries, use ",(0,n.jsx)(t.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/api-slice-utils#upsertquerydata",children:(0,n.jsx)(t.code,{children:"upsertQueryData"})}),"."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"upsertQueryData"})," is intended to perform ",(0,n.jsx)(t.em,{children:"replacements"})," to existing cache entries or ",(0,n.jsx)(t.em,{children:"creation"})," of new ones. Since ",(0,n.jsx)(t.code,{children:"upsertQueryData"})," does not have access to the previous state of the cache entry, the update may be performed only as a replacement. In comparison, ",(0,n.jsx)(t.code,{children:"updateQueryData"})," allows patching of the existing cache entry, but cannot create a new one."]}),"\n",(0,n.jsxs)(t.p,{children:["One example use case is ",(0,n.jsx)(t.a,{href:"/redux-toolkit-zh/rtk-query/usage/manual-cache-updates#pessimistic-updates",children:"pessimistic updates"}),". If the client makes an API call to create a ",(0,n.jsx)(t.code,{children:"Post"}),", the backend could return its complete data including the ",(0,n.jsx)(t.code,{children:"id"}),". Then we can use ",(0,n.jsx)(t.code,{children:"upsertQueryData"})," to create a new cache entry for the ",(0,n.jsx)(t.code,{children:"getPostById(id)"})," query, preventing an extra fetch to retrieve the item later."]}),"\n",(0,n.jsx)(t.h2,{id:"recipes",children:"Recipes"}),"\n",(0,n.jsx)(t.h3,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,n.jsxs)(t.p,{children:["When you wish to perform an update to cache data immediately after a ",(0,n.jsx)(t.a,{href:"./mutations",children:(0,n.jsx)(t.code,{children:"mutation"})})," is\ntriggered, you can apply an ",(0,n.jsx)(t.code,{children:"optimistic update"}),". This can be a useful pattern for when you want to\ngive the user the impression that their changes are immediate, even while the mutation request is\nstill in flight."]}),"\n",(0,n.jsx)(t.p,{children:"The core concepts for an optimistic update are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["when you start a query or mutation, ",(0,n.jsx)(t.code,{children:"onQueryStarted"})," will be executed"]}),"\n",(0,n.jsxs)(t.li,{children:["you manually update the cached data by dispatching ",(0,n.jsx)(t.code,{children:"api.util.updateQueryData"})," within ",(0,n.jsx)(t.code,{children:"onQueryStarted"})]}),"\n",(0,n.jsxs)(t.li,{children:["then, in the case that ",(0,n.jsx)(t.code,{children:"queryFulfilled"})," rejects:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["you roll it back via the ",(0,n.jsx)(t.code,{children:".undo"})," property of the object you got back from the earlier dispatch,\nOR"]}),"\n",(0,n.jsxs)(t.li,{children:["you invalidate the cache data via ",(0,n.jsx)(t.code,{children:"api.util.invalidateTags"})," to trigger a full re-fetch of the data"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["Where many mutations are potentially triggered in short succession causing overlapping requests,\nyou may encounter race conditions if attempting to roll back patches using the ",(0,n.jsx)(t.code,{children:".undo"})," property\non failures. For these scenarios, it is often simplest and safest to invalidate the tags on error\ninstead, and re-fetch truly up-to-date data from the server."]})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:'title="Optimistic update mutation example (async await)"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<void, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          }),\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n\n          /**\n           * Alternatively, on failure you can invalidate the corresponding cache tags\n           * to trigger a re-fetch:\n           * dispatch(api.util.invalidateTags(['Post']))\n           */\n        }\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,n.jsxs)(t.p,{children:["or, if you prefer the slightly shorter version with ",(0,n.jsx)(t.code,{children:".catch"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-diff",children:"-      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n+      onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n-       try {\n-         await queryFulfilled\n-       } catch {\n-         patchResult.undo()\n-       }\n+       queryFulfilled.catch(patchResult.undo)\n      }\n"})}),"\n",(0,n.jsx)(t.h4,{id:"example",children:"Example"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"./examples#react-optimistic-updates",children:"React Optimistic Updates"})}),"\n",(0,n.jsx)(t.h3,{id:"pessimistic-updates",children:"Pessimistic Updates"}),"\n",(0,n.jsxs)(t.p,{children:["When you wish to perform an update to cache data based on the response received from the server\nafter a ",(0,n.jsx)(t.a,{href:"./mutations",children:(0,n.jsx)(t.code,{children:"mutation"})})," is triggered, you can apply a ",(0,n.jsx)(t.code,{children:"pessimistic update"}),".\nThe distinction between a ",(0,n.jsx)(t.code,{children:"pessimistic update"})," and an ",(0,n.jsx)(t.code,{children:"optimistic update"})," is that the\n",(0,n.jsx)(t.code,{children:"pessimistic update"})," will instead wait for the response from the server prior to updating\nthe cached data."]}),"\n",(0,n.jsx)(t.p,{children:"The core concepts for a pessimistic update are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["when you start a query or mutation, ",(0,n.jsx)(t.code,{children:"onQueryStarted"})," will be executed"]}),"\n",(0,n.jsxs)(t.li,{children:["you await ",(0,n.jsx)(t.code,{children:"queryFulfilled"})," to resolve to an object containing the transformed response from the\nserver in the ",(0,n.jsx)(t.code,{children:"data"})," property"]}),"\n",(0,n.jsxs)(t.li,{children:["you manually update the cached data by dispatching ",(0,n.jsx)(t.code,{children:"api.util.updateQueryData"})," within\n",(0,n.jsx)(t.code,{children:"onQueryStarted"}),", using the data in the response from the server for your draft updates"]}),"\n",(0,n.jsxs)(t.li,{children:["you manually create a new cache entry by dispatching ",(0,n.jsx)(t.code,{children:"api.util.upsertQueryData"})," within ",(0,n.jsx)(t.code,{children:"onQueryStarted"}),",\nusing the complete Post object returned by backend."]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:'title="Pessimistic update mutation example (async await)"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            }),\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n    createPost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...body }) => ({\n        url: `post/${id}`,\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      async onQueryStarted({ id }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: createdPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.upsertQueryData('getPost', id, createdPost),\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,n.jsx)(t.h3,{id:"general-updates",children:"General Updates"}),"\n",(0,n.jsxs)(t.p,{children:["If you find yourself wanting to update cache data elsewhere in your application, you can do so\nanywhere you have access to the ",(0,n.jsx)(t.code,{children:"store.dispatch"})," method, including within React components via\nthe ",(0,n.jsx)(t.a,{href:"https://react-redux.js.org/api/hooks#usedispatch",children:"useDispatch"})," hook (or a typed version such\nas ",(0,n.jsx)(t.a,{href:"https://react-redux.js.org/using-react-redux/usage-with-typescript#define-typed-hooks",children:"useAppDispatch"}),"\nfor typescript users)."]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsxs)(t.p,{children:["You should generally avoid manually updating the cache outside of the ",(0,n.jsx)(t.code,{children:"onQueryStarted"}),"\ncallback for a mutation without a good reason, as RTK Query is intended to be used by considering\nyour cached data as a reflection of the server-side state."]})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="General manual cache update example"',children:"import { api } from './api'\nimport { useAppDispatch } from './store/hooks'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n\n  function handleClick() {\n    /**\n     * This will update the cache data for the query corresponding to the `getPosts` endpoint,\n     * when that endpoint is used with no argument (undefined).\n     */\n    const patchCollection = dispatch(\n      api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n        draftPosts.push({ id: 1, name: 'Teddy' })\n      }),\n    )\n  }\n\n  return <button onClick={handleClick}>Add post to cache</button>\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>c});var n=a(6540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);