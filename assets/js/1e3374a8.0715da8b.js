"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[1209],{757:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var c=n(4848),r=n(8453);const a={id:"createSlice",title:"createSlice",sidebar_label:"createSlice",hide_title:!0},s="createSlice",i={id:"api/createSlice",title:"createSlice",description:"&nbsp;",source:"@site/docs/api/createSlice.mdx",sourceDirName:"api",slug:"/api/createSlice",permalink:"/api/createSlice",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api/createSlice.mdx",tags:[],version:"current",frontMatter:{id:"createSlice",title:"createSlice",sidebar_label:"createSlice",hide_title:!0},sidebar:"docs",previous:{title:"createAction",permalink:"/api/createAction"},next:{title:"createAsyncThunk",permalink:"/api/createAsyncThunk"}},o={},l=[{value:"\u53c2\u6570",id:"\u53c2\u6570",level:2},{value:"<code>initialState</code>",id:"initialstate",level:3},{value:"<code>name</code>",id:"name",level:3},{value:"<code>reducers</code>",id:"reducers",level:3},{value:"Customizing Generated Action Creators",id:"customizing-generated-action-creators",level:4},{value:"The <code>reducers</code> &quot;creator callback&quot; notation",id:"the-reducers-creator-callback-notation",level:3},{value:"Create Methods",id:"create-methods",level:4},{value:"<code>create.reducer</code>",id:"createreducer",level:4},{value:"<code>create.preparedReducer</code>",id:"createpreparedreducer",level:4},{value:"<code>create.asyncThunk</code>",id:"createasyncthunk",level:4},{value:"<code>extraReducers</code>",id:"extrareducers",level:3},{value:"The <code>extraReducers</code> &quot;builder callback&quot; notation",id:"the-extrareducers-builder-callback-notation",level:4},{value:"<code>reducerPath</code>",id:"reducerpath",level:3},{value:"<code>selectors</code>",id:"selectors",level:3},{value:"Return Value",id:"return-value",level:2},{value:"Selectors",id:"selectors-1",level:3},{value:"<code>selectors</code>",id:"selectors-2",level:4},{value:"<code>getSelectors</code>",id:"getselectors",level:4},{value:"Examples",id:"examples",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.p,{children:"\xa0"}),"\n",(0,c.jsx)(t.h1,{id:"createslice",children:(0,c.jsx)(t.code,{children:"createSlice"})}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"createSlice"}),'\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e00\u4e2a\u521d\u59cb\u72b6\u6001\uff0c\u4e00\u4e2areducer\u51fd\u6570\u7684\u5bf9\u8c61\uff0c\u4ee5\u53ca\u4e00\u4e2a"slice\u540d\u79f0"\uff0c\u5e76\u81ea\u52a8\u751f\u6210\u4e0ereducers\u548c\u72b6\u6001\u5bf9\u5e94\u7684action\u521b\u5efa\u5668\u548caction\u7c7b\u578b\u3002']}),"\n",(0,c.jsx)(t.p,{children:"\u8fd9\u4e2aAPI\u662f\u7f16\u5199Redux\u903b\u8f91\u7684\u6807\u51c6\u65b9\u6cd5\u3002"}),"\n",(0,c.jsxs)(t.p,{children:["\u5728\u5185\u90e8\uff0c\u5b83\u4f7f\u7528",(0,c.jsx)(t.a,{href:"/api/createAction",children:(0,c.jsx)(t.code,{children:"createAction"})}),"\u548c",(0,c.jsx)(t.a,{href:"/api/createReducer",children:(0,c.jsx)(t.code,{children:"createReducer"})}),"\uff0c\u6240\u4ee5\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528",(0,c.jsx)(t.a,{href:"/usage/immer-reducers",children:"Immer"}),'\u6765\u7f16\u5199"\u53d8\u5f02"\u7684\u4e0d\u53ef\u53d8\u66f4\u65b0\uff1a']}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { createSlice } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst initialState = { value: 0 } \u6ee1\u8db3 CounterState \u4f5c\u4e3a CounterState\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: {\n    increment(state) {\n      state.value++\n    },\n    decrement(state) {\n      state.value--\n    },\n    incrementByAmount(state, action: PayloadAction<number>) {\n      state.value += action.payload\n    },\n  },\n})\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\nexport default counterSlice.reducer\n"})}),"\n",(0,c.jsx)(t.h2,{id:"\u53c2\u6570",children:"\u53c2\u6570"}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"createSlice"}),"\u63a5\u53d7\u4e00\u4e2a\u5355\u72ec\u7684\u914d\u7f6e\u5bf9\u8c61\u53c2\u6570\uff0c\u6709\u4ee5\u4e0b\u9009\u9879\uff1a"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:'function createSlice({\n    // \u4e00\u4e2a\u540d\u79f0\uff0c\u7528\u4e8eaction\u7c7b\u578b\n    name: string,\n    // reducer\u7684\u521d\u59cb\u72b6\u6001\n    initialState: State,\n    // "case reducers"\u7684\u5bf9\u8c61\u3002\u952e\u540d\u5c06\u7528\u4e8e\u751f\u6210actions\u3002\n    reducers: Record<string, ReducerFunction | ReducerAndPrepareObject>,\n    // \u7528\u4e8e\u6dfb\u52a0\u66f4\u591areducers\u7684"builder\u56de\u8c03"\u51fd\u6570\n    extraReducers?: (builder: ActionReducerMapBuilder<State>) => void,\n    // slice reducer\u7684\u4f4d\u7f6e\u504f\u597d\uff0c\u7531`combineSlices`\u548c`slice.selectors`\u4f7f\u7528\u3002\u9ed8\u8ba4\u4e3a`name`\u3002\n    reducerPath?: string,\n    // \u9009\u62e9\u5668\u7684\u5bf9\u8c61\uff0c\u5b83\u4eec\u63a5\u6536slice\u7684\u72b6\u6001\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002\n    selectors?: Record<string, (sliceState: State, ...args: any[]) => any>,\n})\n'})}),"\n",(0,c.jsx)(t.h3,{id:"initialstate",children:(0,c.jsx)(t.code,{children:"initialState"})}),"\n",(0,c.jsx)(t.p,{children:"The initial state value for this slice of state."}),"\n",(0,c.jsxs)(t.p,{children:['This may also be a "lazy initializer" function, which should return an initial state value when called. This will be used whenever the reducer is called with ',(0,c.jsx)(t.code,{children:"undefined"})," as its state value, and is primarily useful for cases like reading initial state from ",(0,c.jsx)(t.code,{children:"localStorage"}),"."]}),"\n",(0,c.jsx)(t.h3,{id:"name",children:(0,c.jsx)(t.code,{children:"name"})}),"\n",(0,c.jsx)(t.p,{children:"A string name for this slice of state. Generated action type constants will use this as a prefix."}),"\n",(0,c.jsx)(t.h3,{id:"reducers",children:(0,c.jsx)(t.code,{children:"reducers"})}),"\n",(0,c.jsx)(t.p,{children:'An object containing Redux "case reducer" functions (functions intended to handle a specific action type, equivalent\nto a single case statement in a switch).'}),"\n",(0,c.jsx)(t.p,{children:"The keys in the object will be used to generate string action type constants, and these will show up in the Redux\nDevTools Extension when they are dispatched. Also, if any other part of the application happens to dispatch an action\nwith the exact same type string, the corresponding reducer will be run. Therefore, you should give the functions\ndescriptive names."}),"\n",(0,c.jsxs)(t.p,{children:["This object will be passed to ",(0,c.jsx)(t.a,{href:"/api/createReducer",children:(0,c.jsx)(t.code,{children:"createReducer"})}),', so the reducers may safely "mutate" the\nstate they are given.']}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { createSlice } from '@reduxjs/toolkit'\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {\n    increment: (state) => state + 1,\n  },\n})\n// Will handle the action type `'counter/increment'`\n"})}),"\n",(0,c.jsx)(t.h4,{id:"customizing-generated-action-creators",children:"Customizing Generated Action Creators"}),"\n",(0,c.jsxs)(t.p,{children:["If you need to customize the creation of the payload value of an action creator by means of a ",(0,c.jsx)(t.a,{href:"/api/createAction#using-prepare-callbacks-to-customize-action-contents",children:(0,c.jsx)(t.code,{children:"prepare callback"})}),", the value of the appropriate field of the ",(0,c.jsx)(t.code,{children:"reducers"})," argument object should be an object instead of a function. This object must contain two properties: ",(0,c.jsx)(t.code,{children:"reducer"})," and ",(0,c.jsx)(t.code,{children:"prepare"}),". The value of the ",(0,c.jsx)(t.code,{children:"reducer"})," field should be the case reducer function while the value of the ",(0,c.jsx)(t.code,{children:"prepare"})," field should be the prepare callback function:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { createSlice, nanoid } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\n\ninterface Item {\n  id: string\n  text: string\n}\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [] as Item[],\n  reducers: {\n    addTodo: {\n      reducer: (state, action: PayloadAction<Item>) => {\n        state.push(action.payload)\n      },\n      prepare: (text: string) => {\n        const id = nanoid()\n        return { payload: { id, text } }\n      },\n    },\n  },\n})\n"})}),"\n",(0,c.jsxs)(t.h3,{id:"the-reducers-creator-callback-notation",children:["The ",(0,c.jsx)(t.code,{children:"reducers"}),' "creator callback" notation']}),"\n",(0,c.jsxs)(t.p,{children:["Alternatively, the ",(0,c.jsx)(t.code,{children:"reducers"}),' field can be a callback which receives a "create" object.']}),"\n",(0,c.jsxs)(t.p,{children:["The main benefit of this is that you can create ",(0,c.jsx)(t.a,{href:"./createAsyncThunk",children:"async thunks"})," as part of your slice (though for bundle size reasons, you ",(0,c.jsx)(t.a,{href:"#createasyncthunk",children:"need a bit of setup for this"}),"). Types are also slightly simplified for prepared reducers."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:'title="Creator callback for reducers"',children:"import { createSlice, nanoid } from '@reduxjs/toolkit'\n\ninterface Item {\n  id: string\n  text: string\n}\n\ninterface TodoState {\n  loading: boolean\n  todos: Item[]\n}\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: {\n    loading: false,\n    todos: [],\n  } satisfies TodoState as TodoState,\n  reducers: (create) => ({\n    deleteTodo: create.reducer<number>((state, action) => {\n      state.todos.splice(action.payload, 1)\n    }),\n    addTodo: create.preparedReducer(\n      (text: string) => {\n        const id = nanoid()\n        return { payload: { id, text } }\n      },\n      // action type is inferred from prepare callback\n      (state, action) => {\n        state.todos.push(action.payload)\n      },\n    ),\n    fetchTodo: create.asyncThunk(\n      async (id: string, thunkApi) => {\n        const res = await fetch(`myApi/todos?id=${id}`)\n        return (await res.json()) as Item\n      },\n      {\n        pending: (state) => {\n          state.loading = true\n        },\n        rejected: (state, action) => {\n          state.loading = false\n        },\n        fulfilled: (state, action) => {\n          state.loading = false\n          state.todos.push(action.payload)\n        },\n      },\n    ),\n  }),\n})\n\nexport const { addTodo, deleteTodo, fetchTodo } = todosSlice.actions\n"})}),"\n",(0,c.jsx)(t.h4,{id:"create-methods",children:"Create Methods"}),"\n",(0,c.jsx)(t.h4,{id:"createreducer",children:(0,c.jsx)(t.code,{children:"create.reducer"})}),"\n",(0,c.jsx)(t.p,{children:"A standard slice case reducer."}),"\n",(0,c.jsx)(t.p,{children:(0,c.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,c.jsxs)(t.ul,{children:["\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"reducer"})," The slice case reducer to use."]}),"\n"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"create.reducer<Todo>((state, action) => {\n  state.todos.push(action.payload)\n})\n"})}),"\n",(0,c.jsx)(t.h4,{id:"createpreparedreducer",children:(0,c.jsx)(t.code,{children:"create.preparedReducer"})}),"\n",(0,c.jsxs)(t.p,{children:["A ",(0,c.jsx)(t.a,{href:"#customizing-generated-action-creators",children:"prepared"})," reducer, to customize the action creator."]}),"\n",(0,c.jsx)(t.p,{children:(0,c.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,c.jsxs)(t.ul,{children:["\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"prepareAction"})," The ",(0,c.jsx)(t.a,{href:"./createAction#using-prepare-callbacks-to-customize-action-contents",children:(0,c.jsx)(t.code,{children:"prepare callback"})}),"."]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"reducer"})," The slice case reducer to use."]}),"\n"]}),"\n",(0,c.jsx)(t.p,{children:"The action passed to the case reducer will be inferred from the prepare callback's return."}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"create.preparedReducer(\n  (text: string) => {\n    const id = nanoid()\n    return { payload: { id, text } }\n  },\n  (state, action) => {\n    state.todos.push(action.payload)\n  },\n)\n"})}),"\n",(0,c.jsx)(t.h4,{id:"createasyncthunk",children:(0,c.jsx)(t.code,{children:"create.asyncThunk"})}),"\n",(0,c.jsx)(t.p,{children:"Creates an async thunk instead of an action creator."}),"\n",(0,c.jsxs)(t.admonition,{title:"Setup",type:"caution",children:[(0,c.jsxs)(t.p,{children:["To avoid pulling ",(0,c.jsx)(t.code,{children:"createAsyncThunk"})," into the bundle size of ",(0,c.jsx)(t.code,{children:"createSlice"})," by default, some extra setup is required to use ",(0,c.jsx)(t.code,{children:"create.asyncThunk"}),"."]}),(0,c.jsxs)(t.p,{children:["The version of ",(0,c.jsx)(t.code,{children:"createSlice"})," exported from RTK will throw an error if ",(0,c.jsx)(t.code,{children:"create.asyncThunk"})," is called."]}),(0,c.jsxs)(t.p,{children:["Instead, import ",(0,c.jsx)(t.code,{children:"buildCreateSlice"})," and ",(0,c.jsx)(t.code,{children:"asyncThunkCreator"}),", and create your own version of ",(0,c.jsx)(t.code,{children:"createSlice"}),":"]}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { buildCreateSlice, asyncThunkCreator } from '@reduxjs/toolkit'\n\nexport const createAppSlice = buildCreateSlice({\n  creators: { asyncThunk: asyncThunkCreator },\n})\n"})}),(0,c.jsxs)(t.p,{children:["Then import this ",(0,c.jsx)(t.code,{children:"createAppSlice"})," as needed instead of the exported version from RTK."]})]}),"\n",(0,c.jsx)(t.p,{children:(0,c.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,c.jsxs)(t.ul,{children:["\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"payloadCreator"})," The thunk ",(0,c.jsx)(t.a,{href:"./createAsyncThunk#payloadcreator",children:"payload creator"}),"."]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"config"})," The configuration object. (optional)"]}),"\n"]}),"\n",(0,c.jsxs)(t.p,{children:["The configuration object can contain case reducers for each of the ",(0,c.jsx)(t.a,{href:"./createAsyncThunk#promise-lifecycle-actions",children:"lifecycle actions"})," (",(0,c.jsx)(t.code,{children:"pending"}),", ",(0,c.jsx)(t.code,{children:"fulfilled"}),", and ",(0,c.jsx)(t.code,{children:"rejected"}),"), as well as a ",(0,c.jsx)(t.code,{children:"settled"})," reducer that will run for both fulfilled and rejected actions (note that this will run ",(0,c.jsx)(t.em,{children:"after"})," any provided ",(0,c.jsx)(t.code,{children:"fulfilled"}),"/",(0,c.jsx)(t.code,{children:"rejected"})," reducers. Conceptually it can be thought of like a ",(0,c.jsx)(t.code,{children:"finally"})," block.)."]}),"\n",(0,c.jsxs)(t.p,{children:["Each case reducer will be attached to the slice's ",(0,c.jsx)(t.code,{children:"caseReducers"})," object, e.g. ",(0,c.jsx)(t.code,{children:"slice.caseReducers.fetchTodo.fulfilled"}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["The configuration object can also contain ",(0,c.jsx)(t.a,{href:"./createAsyncThunk#options",children:(0,c.jsx)(t.code,{children:"options"})}),"."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"create.asyncThunk(\n  async (id: string, thunkApi) => {\n    const res = await fetch(`myApi/todos?id=${id}`)\n    return (await res.json()) as Item\n  },\n  {\n    pending: (state) => {\n      state.loading = true\n    },\n    rejected: (state, action) => {\n      state.error = action.payload ?? action.error\n    },\n    fulfilled: (state, action) => {\n      state.todos.push(action.payload)\n    },\n    settled: (state, action) => {\n      state.loading = false\n    }\n    options: {\n      idGenerator: uuid,\n    },\n  }\n)\n"})}),"\n",(0,c.jsxs)(t.admonition,{type:"note",children:[(0,c.jsxs)(t.p,{children:["Typing for the ",(0,c.jsx)(t.code,{children:"create.asyncThunk"})," works in the same way as ",(0,c.jsx)(t.a,{href:"../usage/usage-with-typescript#createasyncthunk",children:(0,c.jsx)(t.code,{children:"createAsyncThunk"})}),", with one key difference."]}),(0,c.jsxs)(t.p,{children:["A type for ",(0,c.jsx)(t.code,{children:"state"})," and/or ",(0,c.jsx)(t.code,{children:"dispatch"})," ",(0,c.jsx)(t.em,{children:"cannot"})," be provided as part of the ",(0,c.jsx)(t.code,{children:"ThunkApiConfig"}),", as this would cause circular types."]}),(0,c.jsxs)(t.p,{children:["Instead, it is necessary to assert the type when needed - ",(0,c.jsx)(t.code,{children:"getState() as RootState"}),". You may also include an explicit return type for the payload function as well, in order to break the circular type inference cycle."]}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"create.asyncThunk<Todo, string, { rejectValue: { error: string } }>(\n  // highlight-start\n  // may need to include an explicit return type\n  async (id: string, thunkApi): Promise<Todo> => {\n    // Cast types for `getState` and `dispatch` manually\n    const state = thunkApi.getState() as RootState\n    const dispatch = thunkApi.dispatch as AppDispatch\n    // highlight-end\n    try {\n      const todo = await fetchTodo()\n      return todo\n    } catch (e) {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no!',\n      })\n    }\n  },\n)\n"})}),(0,c.jsxs)(t.p,{children:["For common thunk API configuration options, a ",(0,c.jsxs)(t.a,{href:"../usage/usage-with-typescript#defining-a-pre-typed-createasyncthunk",children:[(0,c.jsx)(t.code,{children:"withTypes"})," helper"]})," is provided:"]}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"reducers: (create) => {\n  const createAThunk = create.asyncThunk.withTypes<{\n    rejectValue: { error: string }\n  }>()\n\n  return {\n    fetchTodo: createAThunk<Todo, string>(async (id, thunkApi) => {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no!',\n      })\n    }),\n    fetchTodos: createAThunk<Todo[], string>(async (id, thunkApi) => {\n      throw thunkApi.rejectWithValue({\n        error: 'Oh no, not again!',\n      })\n    }),\n  }\n}\n"})})]}),"\n",(0,c.jsx)(t.h3,{id:"extrareducers",children:(0,c.jsx)(t.code,{children:"extraReducers"})}),"\n",(0,c.jsxs)(t.p,{children:['Conceptually, each slice reducer "owns" its slice of state. There\'s also a natural correspondance between the update logic defined inside ',(0,c.jsx)(t.code,{children:"reducers"}),", and the action types that are generated based on those."]}),"\n",(0,c.jsxs)(t.p,{children:['However, there are many times that a Redux slice may also need to update its own state in response to action types that were defined elsewhere in the application (such as clearing many different kinds of data when a "user logged out" action is dispatched). This can include action types defined by another ',(0,c.jsx)(t.code,{children:"createSlice"})," call, actions generated by a ",(0,c.jsx)(t.code,{children:"createAsyncThunk"}),", RTK Query endpoint matchers, or any other action. In addition, one of the key concepts of Redux is that many slice reducers can independently respond to the same action type."]}),"\n",(0,c.jsx)(t.p,{children:(0,c.jsxs)(t.strong,{children:[(0,c.jsx)(t.code,{children:"extraReducers"})," allows ",(0,c.jsx)(t.code,{children:"createSlice"})," to respond and update its own state in response to other action types besides the types it has generated."]})}),"\n",(0,c.jsxs)(t.p,{children:["As with the ",(0,c.jsx)(t.code,{children:"reducers"})," field, each case reducer in ",(0,c.jsx)(t.code,{children:"extraReducers"})," is ",(0,c.jsx)(t.a,{href:"/usage/immer-reducers",children:'wrapped in Immer and may use "mutating" syntax to safely update the state inside'}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["However, unlike the ",(0,c.jsx)(t.code,{children:"reducers"})," field, each individual case reducer inside of ",(0,c.jsx)(t.code,{children:"extraReducers"})," will ",(0,c.jsx)(t.em,{children:"not"})," generate a new action type or action creator."]}),"\n",(0,c.jsxs)(t.p,{children:["If two fields from ",(0,c.jsx)(t.code,{children:"reducers"})," and ",(0,c.jsx)(t.code,{children:"extraReducers"})," happen to end up with the same action type string, the function from ",(0,c.jsx)(t.code,{children:"reducers"})," will be used to handle that action type."]}),"\n",(0,c.jsxs)(t.h4,{id:"the-extrareducers-builder-callback-notation",children:["The ",(0,c.jsx)(t.code,{children:"extraReducers"}),' "builder callback" notation']}),"\n",(0,c.jsxs)(t.p,{children:["Similar to ",(0,c.jsx)(t.code,{children:"createReducer"}),", the ",(0,c.jsx)(t.code,{children:"extraReducers"}),' field uses a "builder callback" notation to define handlers for specific action types, matching against a range of actions, or handling a default case. This is conceptually similar to a switch statement, but with better TS support as it can infer the action type from the provided action creator. It\'s particularly useful for working with actions produced by ',(0,c.jsx)(t.code,{children:"createAction"})," and ",(0,c.jsx)(t.code,{children:"createAsyncThunk"}),"."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { createAction, createSlice, Action } from '@reduxjs/toolkit'\nconst incrementBy = createAction<number>('incrementBy')\nconst decrement = createAction('decrement')\n\ninterface RejectedAction extends Action {\n  error: Error\n}\n\nfunction isRejectedAction(action: Action): action is RejectedAction {\n  return action.type.endsWith('rejected')\n}\n\ncreateSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {},\n  extraReducers: builder => {\n    builder\n      .addCase(incrementBy, (state, action) => {\n        // action is inferred correctly here if using TS\n      })\n      // You can chain calls, or have separate `builder.addCase()` lines each time\n      .addCase(decrement, (state, action) => {})\n      // You can match a range of action types\n      .addMatcher(\n        isRejectedAction,\n        // `action` will be inferred as a RejectedAction due to isRejectedAction being defined as a type guard\n        (state, action) => {}\n      )\n      // and provide a default case if no other handlers matched\n      .addDefaultCase((state, action) => {})\n    }\n})\n"})}),"\n",(0,c.jsxs)(t.p,{children:["See ",(0,c.jsxs)(t.a,{href:"/api/createReducer#usage-with-the-builder-callback-notation",children:['the "Builder Callback Notation" section of the ',(0,c.jsx)(t.code,{children:"createReducer"})," reference"]})," for details on how to use ",(0,c.jsx)(t.code,{children:"builder.addCase"}),", ",(0,c.jsx)(t.code,{children:"builder.addMatcher"}),", and ",(0,c.jsx)(t.code,{children:"builder.addDefaultCase"})]}),"\n",(0,c.jsx)(t.h3,{id:"reducerpath",children:(0,c.jsx)(t.code,{children:"reducerPath"})}),"\n",(0,c.jsxs)(t.p,{children:["Indicates a preference of where the slice should be located. Defaults to ",(0,c.jsx)(t.a,{href:"#name",children:(0,c.jsx)(t.code,{children:"name"})}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["This is used by ",(0,c.jsx)(t.code,{children:"combineSlices"})," and the default generated ",(0,c.jsx)(t.code,{children:"slice.selectors"}),"."]}),"\n",(0,c.jsx)(t.h3,{id:"selectors",children:(0,c.jsx)(t.code,{children:"selectors"})}),"\n",(0,c.jsx)(t.p,{children:"A set of selectors that receive the slice state as their first parameter, and any other parameters."}),"\n",(0,c.jsxs)(t.p,{children:["Each selector will have a corresponding key in the resulting ",(0,c.jsx)(t.a,{href:"#selectors-1",children:(0,c.jsx)(t.code,{children:"selectors"})})," object."]}),"\n",(0,c.jsxs)(t.admonition,{title:"Circular types",type:"caution",children:[(0,c.jsx)(t.p,{children:"It's fairly common to have selectors that use other selectors. This is still possible with slice selectors, but defining a selector without a return type can cause a circular type inference problem:"}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"const counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {},\n  selectors: {\n    selectValue: (state) => state.value,\n    // highlight-start\n    // this creates a cycle, because it's inferring a type from the object we're creating here\n    selectTimes: (state, times = 1) =>\n      counterSlice.getSelectors().selectValue(state) * times,\n    // highlight-end\n  },\n})\n"})}),(0,c.jsx)(t.p,{children:"This cycle can be fixed by providing an explicit return type for the selector:"}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"const counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {},\n  selectors: {\n    selectValue: (state) => state.value,\n    // highlight-start\n    // explicit return type means cycle is broken\n    selectTimes: (state, times = 1): number =>\n      counterSlice.getSelectors().selectValue(state) * times,\n    // highlight-end\n  },\n})\n"})}),(0,c.jsxs)(t.p,{children:["This limitation may be also encountered when using a slice's ",(0,c.jsx)(t.code,{children:"asyncThunk"})," creator.\nIn the same way, the issue is resolved by explicitly providing a type somewhere in the chain and breaking the cycle."]}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"const counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: (create) => ({\n    getCountData: create.asyncThunk(async (_arg, { getState }) => {\n      const currentCount = counterSlice.selectors.selectValue(\n        getState() as RootState,\n      )\n      // highlight-start\n      // this would cause a circular type, but the type annotation breaks the circle\n      const result: Response = await fetch('api/' + currentCount)\n      // highlight-end\n      return result.json()\n    }),\n  }),\n  selectors: {\n    selectValue: (state) => state.value,\n  },\n})\n"})})]}),"\n",(0,c.jsx)(t.h2,{id:"return-value",children:"Return Value"}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"createSlice"})," will return an object that looks like:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"{\n    name: string,\n    reducer: ReducerFunction,\n    actions: Record<string, ActionCreator>,\n    caseReducers: Record<string, CaseReducer>.\n    getInitialState: () => State,\n    reducerPath: string,\n    selectSlice: Selector;\n    selectors: Record<string, Selector>,\n    getSelectors: (selectState: (rootState: RootState) => State) => Record<string, Selector>\n    injectInto: (injectable: Injectable, config?: InjectConfig & { reducerPath?: string }) => InjectedSlice\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Each function defined in the ",(0,c.jsx)(t.code,{children:"reducers"})," argument will have a corresponding action creator generated using ",(0,c.jsx)(t.a,{href:"/api/createAction",children:(0,c.jsx)(t.code,{children:"createAction"})}),"\nand included in the result's ",(0,c.jsx)(t.code,{children:"actions"})," field using the same function name."]}),"\n",(0,c.jsxs)(t.p,{children:["The generated ",(0,c.jsx)(t.code,{children:"reducer"})," function is suitable for passing to the Redux ",(0,c.jsx)(t.code,{children:"combineReducers"}),' function as a "slice reducer".']}),"\n",(0,c.jsx)(t.p,{children:"You may want to consider destructuring the action creators and exporting them individually, for ease of searching\nfor references in a larger codebase."}),"\n",(0,c.jsxs)(t.p,{children:["The functions passed to the ",(0,c.jsx)(t.code,{children:"reducers"})," parameter can be accessed through the ",(0,c.jsx)(t.code,{children:"caseReducers"})," return field. This can be particularly useful for testing or direct access to reducers created inline."]}),"\n",(0,c.jsxs)(t.p,{children:["Result's function ",(0,c.jsx)(t.code,{children:"getInitialState"})," provides access to the initial state value given to the slice. If a lazy state initializer was provided, it will be called and a fresh value returned."]}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"injectInto"})," creates an instance of the slice that is aware it's been injected - see ",(0,c.jsx)(t.a,{href:"./combineSlices#slice-integration",children:(0,c.jsx)(t.code,{children:"combineSlices"})}),"."]}),"\n",(0,c.jsx)(t.admonition,{type:"note",children:(0,c.jsxs)(t.p,{children:["The result object is conceptually similar to a\n",(0,c.jsx)(t.a,{href:"https://redux.js.org/faq/code-structure#what-should-my-file-structure-look-like-how-should-i-group-my-action-creators-and-reducers-in-my-project-where-should-my-selectors-go",children:'"Redux duck" code structure'}),".\nThe actual code structure you use is up to you, but it's worth keeping in mind that actions are not exclusively limited to a single slice.\nAny part of the reducer logic can (and should!) respond to any dispatched action."]})}),"\n",(0,c.jsx)(t.h3,{id:"selectors-1",children:"Selectors"}),"\n",(0,c.jsx)(t.p,{children:"Slice selectors are written to expect the slice's state as their first parameter, but the slice may be located anywhere inside the store's root state."}),"\n",(0,c.jsx)(t.p,{children:"As a result, there are two ways of getting final selectors:"}),"\n",(0,c.jsx)(t.h4,{id:"selectors-2",children:(0,c.jsx)(t.code,{children:"selectors"})}),"\n",(0,c.jsxs)(t.p,{children:["Most commonly, the slice is reliably mounted under its ",(0,c.jsx)(t.a,{href:"#reducerPath",children:(0,c.jsx)(t.code,{children:"reducerPath"})}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["Following this, the slice has a ",(0,c.jsx)(t.code,{children:"selectSlice"})," selector attached, which assumes that the slice is located under ",(0,c.jsx)(t.code,{children:"rootState[slice.reducerPath]"}),"."]}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"slice.selectors"})," then uses this selector to wrap each of the selectors provided."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { createSlice } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 } satisfies CounterState as CounterState,\n  reducers: {\n    // omitted\n  },\n  selectors: {\n    selectValue: (sliceState) => sliceState.value,\n  },\n})\n\nconsole.log(counterSlice.selectSlice({ counter: { value: 2 } })) // { value: 2 }\n\nconst { selectValue } = counterSlice.selectors\n\nconsole.log(selectValue({ counter: { value: 2 } })) // 2\n"})}),"\n",(0,c.jsxs)(t.admonition,{type:"note",children:[(0,c.jsxs)(t.p,{children:["The original selector passed is attached to the wrapped selector as ",(0,c.jsx)(t.code,{children:".unwrapped"}),". For example:"]}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { createSlice, createSelector } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 } satisfies CounterState as CounterState,\n  reducers: {\n    // omitted\n  },\n  selectors: {\n    selectDouble: createSelector(\n      (sliceState: CounterState) => sliceState.value,\n      (value) => value * 2,\n    ),\n  },\n})\n\nconst { selectDouble } = counterSlice.selectors\n\nconsole.log(selectDouble({ counter: { value: 2 } })) // 4\nconsole.log(selectDouble({ counter: { value: 3 } })) // 6\nconsole.log(selectDouble.unwrapped.recomputations) // 2\n"})})]}),"\n",(0,c.jsx)(t.h4,{id:"getselectors",children:(0,c.jsx)(t.code,{children:"getSelectors"})}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"slice.getSelectors"})," is called with a single parameter, a ",(0,c.jsx)(t.code,{children:"selectState"})," callback. This function should receive the store root state (or whatever you expect to call the resulting selectors with) and return the slice state."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"const { selectValue } = counterSlice.getSelectors(\n  (rootState: RootState) => rootState.aCounter,\n)\n\nconsole.log(selectValue({ aCounter: { value: 2 } })) // 2\n"})}),"\n",(0,c.jsxs)(t.p,{children:["If no ",(0,c.jsx)(t.code,{children:"selectState"})," callback is passed, selectors will be returned as is - expecting the slice state as their first parameter (the same as calling ",(0,c.jsx)(t.code,{children:"slice.getSelectors(state => state)"}),")."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"const { selectValue } = counterSlice.getSelectors()\n\nconsole.log(selectValue({ value: 2 })) // 2\n"})}),"\n",(0,c.jsxs)(t.admonition,{type:"note",children:[(0,c.jsxs)(t.p,{children:["The ",(0,c.jsx)(t.a,{href:"#selectors-2",children:(0,c.jsx)(t.code,{children:"slice.selectors"})})," object is the equivalent of calling"]}),(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"const { selectValue } = counterSlice.getSelectors(counterSlice.selectSlice)\n// or\nconst { selectValue } = counterSlice.getSelectors(\n  (state: RootState) => state[counterSlice.reducerPath],\n)\n"})})]}),"\n",(0,c.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"import { createSlice, createAction, configureStore } from '@reduxjs/toolkit'\nimport type { PayloadAction } from '@reduxjs/toolkit'\nimport { combineReducers } from 'redux'\n\nconst incrementBy = createAction<number>('incrementBy')\nconst decrementBy = createAction<number>('decrementBy')\n\nconst counter = createSlice({\n  name: 'counter',\n  initialState: 0 satisfies number as number,\n  reducers: {\n    increment: (state) => state + 1,\n    decrement: (state) => state - 1,\n    multiply: {\n      reducer: (state, action: PayloadAction<number>) => state * action.payload,\n      prepare: (value?: number) => ({ payload: value || 2 }), // fallback if the payload is a falsy value\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(incrementBy, (state, action) => {\n      return state + action.payload\n    })\n    builder.addCase(decrementBy, (state, action) => {\n      return state - action.payload\n    })\n  },\n})\n\nconst user = createSlice({\n  name: 'user',\n  initialState: { name: '', age: 20 },\n  reducers: {\n    setUserName: (state, action) => {\n      state.name = action.payload // mutate the state all you want with immer\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(counter.actions.increment, (state, action) => {\n      state.age += 1\n    })\n  },\n})\n\nconst store = configureStore({\n  reducer: {\n    counter: counter.reducer,\n    user: user.reducer,\n  },\n})\n\nstore.dispatch(counter.actions.increment())\n// -> { counter: 1, user: {name : '', age: 21} }\nstore.dispatch(counter.actions.increment())\n// -> { counter: 2, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply(3))\n// -> { counter: 6, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply())\n// -> { counter: 12, user: {name: '', age: 22} }\nconsole.log(counter.actions.decrement.type)\n// -> \"counter/decrement\"\nstore.dispatch(user.actions.setUserName('eric'))\n// -> { counter: 12, user: { name: 'eric', age: 22} }\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var c=n(6540);const r={},a=c.createContext(r);function s(e){const t=c.useContext(a);return c.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),c.createElement(a.Provider,{value:t},e.children)}}}]);