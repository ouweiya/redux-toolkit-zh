"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[6760],{7372:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>l,frontMatter:()=>c,metadata:()=>s,toc:()=>h});var a=t(4848),i=t(8453);const c={id:"autoBatchEnhancer",title:"autoBatchEnhancer",sidebar_label:"autoBatchEnhancer",hide_title:!0},r="autoBatchEnhancer",s={id:"api/autoBatchEnhancer",title:"autoBatchEnhancer",description:"&nbsp;",source:"@site/docs/api/autoBatchEnhancer.mdx",sourceDirName:"api",slug:"/api/autoBatchEnhancer",permalink:"/api/autoBatchEnhancer",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api/autoBatchEnhancer.mdx",tags:[],version:"current",frontMatter:{id:"autoBatchEnhancer",title:"autoBatchEnhancer",sidebar_label:"autoBatchEnhancer",hide_title:!0},sidebar:"docs",previous:{title:"getDefaultEnhancers",permalink:"/api/getDefaultEnhancers"},next:{title:"createReducer",permalink:"/api/createReducer"}},o={},h=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"API",id:"api",level:2},{value:"<code>autoBatchEnhancer</code>",id:"autobatchenhancer-1",level:3},{value:"<code>prepareAutoBatched</code>",id:"prepareautobatched",level:3},{value:"Batching Approach and Background",id:"batching-approach-and-background",level:2},{value:"RTK Query and Batching",id:"rtk-query-and-batching",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"\xa0"}),"\n",(0,a.jsx)(n.h1,{id:"autobatchenhancer",children:(0,a.jsx)(n.code,{children:"autoBatchEnhancer"})}),"\n",(0,a.jsx)(n.p,{children:'A Redux store enhancer that looks for one or more "low-priority" dispatched actions in a row, and queues a callback to run subscriber notifications on a delay. It then notifies subscribers either when the queued callback runs, or when the next "normal-priority" action is dispatched, whichever is first.'}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import {\n  createSlice,\n  configureStore,\n  autoBatchEnhancer,\n  prepareAutoBatched,\n} from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 } satisfies CounterState as CounterState,\n  reducers: {\n    incrementBatched: {\n      // Batched, low-priority\n      reducer(state) {\n        state.value += 1\n      },\n      // highlight-start\n      // Use the `prepareAutoBatched` utility to automatically\n      // add the `action.meta[SHOULD_AUTOBATCH]` field the enhancer needs\n      prepare: prepareAutoBatched<void>(),\n      // highlight-end\n    },\n    // Not batched, normal priority\n    decrementUnbatched(state) {\n      state.value -= 1\n    },\n  },\n})\nconst { incrementBatched, decrementUnbatched } = counterSlice.actions\n\n// includes batch enhancer by default, as of RTK 2.0\nconst store = configureStore({\n  reducer: counterSlice.reducer,\n})\n"})}),"\n",(0,a.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,a.jsx)(n.h3,{id:"autobatchenhancer-1",children:(0,a.jsx)(n.code,{children:"autoBatchEnhancer"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="autoBatchEnhancer signature" no-transpile',children:"export type SHOULD_AUTOBATCH = string\ntype AutoBatchOptions =\n  | { type: 'tick' }\n  | { type: 'timer'; timeout: number }\n  | { type: 'raf' }\n  | { type: 'callback'; queueNotification: (notify: () => void) => void }\n\nexport type autoBatchEnhancer = (options?: AutoBatchOptions) => StoreEnhancer\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["As of RTK 2.0, the ",(0,a.jsx)(n.code,{children:"autoBatchEnhancer"})," is included by default when calling ",(0,a.jsx)(n.code,{children:"configureStore"}),"."]}),(0,a.jsxs)(n.p,{children:["This means to configure it, you should instead pass an callback that receives ",(0,a.jsx)(n.code,{children:"getDefaultEnhancers"})," and calls it with your desired settings."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Configuring autoBatchEnhancer with getDefaultEnhancers"',children:"import { configureStore } from '@reduxjs/toolkit'\n\nconst store = configureStore({\n  reducer: () => 0,\n  enhancers: (getDefaultEnhancers) =>\n    getDefaultEnhancers({\n      autoBatch: { type: 'tick' },\n    }),\n})\n"})})]}),"\n",(0,a.jsx)(n.p,{children:"Creates a new instance of the autobatch store enhancer."}),"\n",(0,a.jsxs)(n.p,{children:["Any action that is tagged with ",(0,a.jsx)(n.code,{children:"action.meta[SHOULD_AUTOBATCH] = true"}),' will be treated as "low-priority", and a notification callback will be queued. The enhancer will delay notifying subscribers until either:']}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The queued callback runs and triggers the notifications"}),"\n",(0,a.jsxs)(n.li,{children:['A "normal-priority" action (any action ',(0,a.jsx)(n.em,{children:"without"})," ",(0,a.jsx)(n.code,{children:"action.meta[SHOULD_AUTOBATCH] = true"}),") is dispatched in the same tick"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"autoBatchEnhancer"})," accepts options to configure how the notification callback is queued:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"{type: 'raf'}"}),": queues using ",(0,a.jsx)(n.code,{children:"requestAnimationFrame"})," (default)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"{type: 'tick'}"}),": queues using ",(0,a.jsx)(n.code,{children:"queueMicrotask"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"{type: 'timer', timeout: number}"}),": queues using ",(0,a.jsx)(n.code,{children:"setTimeout"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"{type: 'callback', queueNotification: (notify: () => void) => void}"}),": lets you provide your own callback, such as a debounced or throttled function"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The default behavior is to queue the notifications using ",(0,a.jsx)(n.code,{children:"requestAnimationFrame"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SHOULD_AUTOBATCH"})," value is meant to be opaque - it's currently a string for simplicity, but could be a ",(0,a.jsx)(n.code,{children:"Symbol"})," in the future."]}),"\n",(0,a.jsx)(n.h3,{id:"prepareautobatched",children:(0,a.jsx)(n.code,{children:"prepareAutoBatched"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="prepareAutoBatched signature" no-transpile',children:"type prepareAutoBatched = <T>() => (payload: T) => { payload: T; meta: unknown }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Creates a function that accepts a ",(0,a.jsx)(n.code,{children:"payload"})," value, and returns an object with ",(0,a.jsx)(n.code,{children:"{payload, meta: {[SHOULD_AUTOBATCH]: true}}"}),". This is meant to be used with RTK's ",(0,a.jsx)(n.code,{children:"createSlice"}),' and its "',(0,a.jsx)(n.code,{children:"prepare"}),' callback" syntax:']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    todoAdded: {\n      reducer(state, action: PayloadAction<Todo>) {\n        state.push(action.payload)\n      },\n      // highlight-start\n      prepare: prepareAutoBatched<Todo>(),\n      // highlight-end\n    },\n  },\n})\n"})}),"\n",(0,a.jsx)(n.h2,{id:"batching-approach-and-background",children:"Batching Approach and Background"}),"\n",(0,a.jsxs)(n.p,{children:["The post ",(0,a.jsx)(n.a,{href:"https://blog.isquaredsoftware.com/2020/01/blogged-answers-redux-batching-techniques/",children:"A Comparison of Redux Batching Techniques"}),' describes four different approaches for "batching Redux actions/dispatches"']}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"a higher-order reducer that accepts multiple actions nested inside one real action, and iterates over them together"}),"\n",(0,a.jsxs)(n.li,{children:["an enhancer that wraps ",(0,a.jsx)(n.code,{children:"dispatch"})," and debounces the notification callback"]}),"\n",(0,a.jsxs)(n.li,{children:["an enhancer that wraps ",(0,a.jsx)(n.code,{children:"dispatch"})," to accept an array of actions"]}),"\n",(0,a.jsxs)(n.li,{children:["React's ",(0,a.jsx)(n.code,{children:"unstable_batchedUpdates()"}),", which just combines multiple queued renders into one but doesn't affect subscriber notifications"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'This enhancer is a variation of the "debounce" approach, but with a twist.'}),"\n",(0,a.jsxs)(n.p,{children:["Instead of ",(0,a.jsx)(n.em,{children:"just"})," debouncing ",(0,a.jsx)(n.em,{children:"all"})," subscriber notifications, it watches for any actions with a specific ",(0,a.jsx)(n.code,{children:"action.meta[SHOULD_AUTOBATCH]: true"})," field attached."]}),"\n",(0,a.jsxs)(n.p,{children:["When it sees an action with that field, it queues a callback. The reducer is updated immediately, but the enhancer does ",(0,a.jsx)(n.em,{children:"not"})," notify subscribers right way. If other actions with the same field are dispatched in succession, the enhancer will continue to ",(0,a.jsx)(n.em,{children:"not"})," notify subscribers. Then, when the queued callback runs, it finally notifies all subscribers, similar to how React batches re-renders."]}),"\n",(0,a.jsx)(n.p,{children:'The additional twist is also inspired by React\'s separation of updates into "low-priority" and "immediate" behavior (such as a render queued by an AJAX request vs a render queued by a user input that should be handled synchronously).'}),"\n",(0,a.jsxs)(n.p,{children:["If some low-pri actions have been dispatched and a notification microtask is queued, then a ",(0,a.jsx)(n.em,{children:"normal"})," priority action (without the field) is dispatched, the enhancer will go ahead and notify all subscribers synchronously as usual, and ",(0,a.jsx)(n.em,{children:"not"})," notify them at the end of the tick."]}),"\n",(0,a.jsx)(n.p,{children:"This allows Redux users to selectively tag certain actions for effective batching behavior, making this purely opt-in on a per-action basis, while retaining normal notification behavior for all other actions."}),"\n",(0,a.jsx)(n.h3,{id:"rtk-query-and-batching",children:"RTK Query and Batching"}),"\n",(0,a.jsxs)(n.p,{children:["RTK Query already marks several of its key internal action types as batchable. By adding the ",(0,a.jsx)(n.code,{children:"autoBatchEnhancer"})," to the store setup, it improves the overall UI performance, especially when rendering large lists of components that use the RTKQ query hooks."]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(6540);const i={},c=a.createContext(i);function r(e){const n=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(c.Provider,{value:n},e.children)}}}]);