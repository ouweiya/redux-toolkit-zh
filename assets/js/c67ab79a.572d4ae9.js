"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[5399],{7002:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var t=r(4848),s=r(8453);const a={id:"customizing-queries",title:"Customizing Queries",sidebar_label:"Customizing Queries",hide_title:!0,description:"RTK Query > Usage > Customizing Queries: overriding default query behavior"},i="Customizing queries",o={id:"rtk-query/usage/customizing-queries",title:"Customizing Queries",description:"RTK Query > Usage > Customizing Queries: overriding default query behavior",source:"@site/docs/rtk-query/usage/customizing-queries.mdx",sourceDirName:"rtk-query/usage",slug:"/rtk-query/usage/customizing-queries",permalink:"/rtk-query/usage/customizing-queries",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rtk-query/usage/customizing-queries.mdx",tags:[],version:"current",frontMatter:{id:"customizing-queries",title:"Customizing Queries",sidebar_label:"Customizing Queries",hide_title:!0,description:"RTK Query > Usage > Customizing Queries: overriding default query behavior"},sidebar:"docs",previous:{title:"Customizing createApi",permalink:"/rtk-query/usage/customizing-create-api"},next:{title:"Usage Without React Hooks",permalink:"/rtk-query/usage/usage-without-react-hooks"}},d={},l=[{value:"Customizing queries with <code>baseQuery</code>",id:"customizing-queries-with-basequery",level:2},{value:"Implementing a custom <code>baseQuery</code>",id:"implementing-a-custom-basequery",level:3},{value:"baseQuery function arguments",id:"basequery-function-arguments",level:4},{value:"baseQuery function return value",id:"basequery-function-return-value",level:4},{value:"fetchBaseQuery defaults",id:"fetchbasequery-defaults",level:4},{value:"Customizing query responses with <code>transformResponse</code>",id:"customizing-query-responses-with-transformresponse",level:2},{value:"Customizing query responses with <code>transformErrorResponse</code>",id:"customizing-query-responses-with-transformerrorresponse",level:2},{value:"Customizing queries with <code>queryFn</code>",id:"customizing-queries-with-queryfn",level:2},{value:"Implementing a <code>queryFn</code>",id:"implementing-a-queryfn",level:3},{value:"Basic <code>queryFn</code> Example",id:"basic-queryfn-example",level:4},{value:"queryFn function arguments",id:"queryfn-function-arguments",level:4},{value:"queryFn function return value",id:"queryfn-function-return-value",level:4},{value:"Examples - <code>baseQuery</code>",id:"examples---basequery",level:2},{value:"Axios baseQuery",id:"axios-basequery",level:3},{value:"GraphQL baseQuery",id:"graphql-basequery",level:3},{value:"Automatic re-authorization by extending fetchBaseQuery",id:"automatic-re-authorization-by-extending-fetchbasequery",level:3},{value:"Preventing multiple unauthorized errors",id:"preventing-multiple-unauthorized-errors",level:4},{value:"Automatic retries",id:"automatic-retries",level:3},{value:"Bailing out of error re-tries",id:"bailing-out-of-error-re-tries",level:4},{value:"Adding Meta information to queries",id:"adding-meta-information-to-queries",level:3},{value:"Constructing a Dynamic Base URL using Redux state",id:"constructing-a-dynamic-base-url-using-redux-state",level:3},{value:"Examples - <code>transformResponse</code>",id:"examples---transformresponse",level:2},{value:"Unpacking deeply nested GraphQL data",id:"unpacking-deeply-nested-graphql-data",level:3},{value:"Normalizing data with <code>createEntityAdapter</code>",id:"normalizing-data-with-createentityadapter",level:3},{value:"Examples - <code>queryFn</code>",id:"examples---queryfn",level:2},{value:"Using a Third-Party SDK",id:"using-a-third-party-sdk",level:3},{value:"Using a no-op queryFn",id:"using-a-no-op-queryfn",level:3},{value:"Streaming data with no initial request",id:"streaming-data-with-no-initial-request",level:3},{value:"Performing multiple requests with a single query",id:"performing-multiple-requests-with-a-single-query",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"\xa0"}),"\n",(0,t.jsx)(n.h1,{id:"customizing-queries",children:"Customizing queries"}),"\n",(0,t.jsx)(n.p,{children:"RTK Query is agnostic as to how your requests resolve. You can use any library you like to handle requests, or no library at all. RTK Query provides reasonable defaults expected to cover the majority of use cases, while also allowing room for customization to alter query handling to fit specific needs."}),"\n",(0,t.jsxs)(n.h2,{id:"customizing-queries-with-basequery",children:["Customizing queries with ",(0,t.jsx)(n.code,{children:"baseQuery"})]}),"\n",(0,t.jsxs)(n.p,{children:["The default method to handle queries is via the ",(0,t.jsx)(n.a,{href:"../api/createApi#basequery",children:(0,t.jsx)(n.code,{children:"baseQuery"})})," option on ",(0,t.jsx)(n.a,{href:"../api/createApi",children:(0,t.jsx)(n.code,{children:"createApi"})}),", in combination with the ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#query",children:(0,t.jsx)(n.code,{children:"query"})})," option on an endpoint definition."]}),"\n",(0,t.jsxs)(n.p,{children:["To process queries, endpoints are defined with a ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#query",children:(0,t.jsx)(n.code,{children:"query"})})," option, which passes its return value to a common ",(0,t.jsx)(n.a,{href:"../api/createApi#basequery",children:(0,t.jsx)(n.code,{children:"baseQuery"})})," function used for the API."]}),"\n",(0,t.jsxs)(n.p,{children:["By default, RTK Query ships with ",(0,t.jsx)(n.a,{href:"../api/fetchBaseQuery",children:(0,t.jsx)(n.code,{children:"fetchBaseQuery"})}),", which is a lightweight ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",children:(0,t.jsx)(n.code,{children:"fetch"})})," wrapper that automatically handles request headers and response parsing in a manner similar to common libraries like ",(0,t.jsx)(n.code,{children:"axios"}),". If ",(0,t.jsx)(n.code,{children:"fetchBaseQuery"})," alone does not meet your needs, you can customize its behaviour with a wrapper function, or create your own ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#basequery",children:(0,t.jsx)(n.code,{children:"baseQuery"})})," function from scratch for ",(0,t.jsx)(n.a,{href:"../api/createApi",children:(0,t.jsx)(n.code,{children:"createApi"})})," to use."]}),"\n",(0,t.jsxs)(n.p,{children:["See also ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#basequery",children:(0,t.jsx)(n.code,{children:"baseQuery API Reference"})}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"implementing-a-custom-basequery",children:["Implementing a custom ",(0,t.jsx)(n.code,{children:"baseQuery"})]}),"\n",(0,t.jsxs)(n.p,{children:["RTK Query expects a ",(0,t.jsx)(n.code,{children:"baseQuery"})," function to be called with three arguments: ",(0,t.jsx)(n.code,{children:"args"}),", ",(0,t.jsx)(n.code,{children:"api"}),", and ",(0,t.jsx)(n.code,{children:"extraOptions"}),". It is expected to return an object with either a ",(0,t.jsx)(n.code,{children:"data"})," or ",(0,t.jsx)(n.code,{children:"error"})," property, or a promise that resolves to return such an object."]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["Base query and query functions must ",(0,t.jsx)(n.em,{children:"always"})," catch errors themselves, and return it in an object!"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"function brokenCustomBaseQuery() {\n  // \u274c Don't let this throw by itself\n  const data = await fetchSomeData()\n  return { data }\n}\n\nfunction correctCustomBaseQuery() {\n  // \u2705 Catch errors and _return_ them so the RTKQ logic can track it\n  try {\n    const data = await fetchSomeData()\n    return { data }\n  } catch (error) {\n    return { error }\n  }\n}\n"})})]}),"\n",(0,t.jsx)(n.h4,{id:"basequery-function-arguments",children:"baseQuery function arguments"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="baseQuery example arguments" no-transpile',children:"const customBaseQuery = (\n  // highlight-start\n  args,\n  { signal, dispatch, getState },\n  extraOptions,\n  // highlight-end\n) => {\n  // omitted\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"basequery-function-return-value",children:"baseQuery function return value"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected success result format" no-transpile',children:"return { data: YourData }\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected error result format" no-transpile',children:"return { error: YourError }\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="baseQuery example return value" no-transpile',children:"const customBaseQuery = (\n  args,\n  { signal, dispatch, getState },\n  extraOptions,\n) => {\n  // highlight-start\n  if (Math.random() > 0.5) return { error: 'Too high!' }\n  return { data: 'All good!' }\n  // highlight-end\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"This format is required so that RTK Query can infer the return types for your responses."})}),"\n",(0,t.jsxs)(n.p,{children:["At its core, a ",(0,t.jsx)(n.code,{children:"baseQuery"})," function only needs to have the minimum return value to be valid; an object with a ",(0,t.jsx)(n.code,{children:"data"})," or ",(0,t.jsx)(n.code,{children:"error"})," property. It is up to the user to determine how they wish to use the provided arguments, and how requests are handled within the function itself."]}),"\n",(0,t.jsx)(n.h4,{id:"fetchbasequery-defaults",children:"fetchBaseQuery defaults"}),"\n",(0,t.jsxs)(n.p,{children:["For ",(0,t.jsx)(n.a,{href:"../api/fetchBaseQuery",children:(0,t.jsx)(n.code,{children:"fetchBaseQuery"})})," specifically, the return type is as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Return types of fetchBaseQuery" no-transpile',children:"Promise<\n  | {\n      data: any\n      error?: undefined\n      meta?: { request: Request; response: Response }\n    }\n  | {\n      error: {\n        status: number\n        data: any\n      }\n      data?: undefined\n      meta?: { request: Request; response: Response }\n    }\n>\n"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected success result format with fetchBaseQuery" no-transpile',children:"return { data: YourData }\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected error result format with fetchBaseQuery" no-transpile',children:"return { error: { status: number, data: YourErrorData } }\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"customizing-query-responses-with-transformresponse",children:["Customizing query responses with ",(0,t.jsx)(n.code,{children:"transformResponse"})]}),"\n",(0,t.jsxs)(n.p,{children:["Individual endpoints on ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi",children:(0,t.jsx)(n.code,{children:"createApi"})})," accept a ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi",children:(0,t.jsx)(n.code,{children:"transformResponse"})})," property which allows manipulation of the data returned by a query or mutation before it hits the cache."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"transformResponse"})," is called with the data that a successful ",(0,t.jsx)(n.code,{children:"baseQuery"})," returns for the corresponding endpoint, and the return value of ",(0,t.jsx)(n.code,{children:"transformResponse"})," is used as the cached data associated with that endpoint call."]}),"\n",(0,t.jsx)(n.p,{children:"By default, the payload from the server is returned directly."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function defaultTransformResponse(\n  baseQueryReturnValue: unknown,\n  meta: unknown,\n  arg: unknown,\n) {\n  return baseQueryReturnValue\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"To change it, provide a function that looks like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Unpack a deeply nested collection" no-transpile',children:"transformResponse: (response, meta, arg) =>\n  response.some.deeply.nested.collection\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"transformResponse"})," is called with the ",(0,t.jsx)(n.code,{children:"meta"})," property returned from the ",(0,t.jsx)(n.code,{children:"baseQuery"})," as its second\nargument, which can be used while determining the transformed response. The value for ",(0,t.jsx)(n.code,{children:"meta"})," is\ndependent on the ",(0,t.jsx)(n.code,{children:"baseQuery"})," used."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="transformResponse meta example" no-transpile',children:"transformResponse: (response: { sideA: Tracks; sideB: Tracks }, meta, arg) => {\n  if (meta?.coinFlip === 'heads') {\n    return response.sideA\n  }\n  return response.sideB\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"transformResponse"})," is called with the ",(0,t.jsx)(n.code,{children:"arg"})," property provided to the endpoint as its third\nargument, which can be used while determining the transformed response. The value for ",(0,t.jsx)(n.code,{children:"arg"})," is\ndependent on the ",(0,t.jsx)(n.code,{children:"endpoint"})," used, as well as the argument used when calling the query/mutation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="transformResponse arg example" no-transpile',children:"transformResponse: (response: Posts, meta, arg) => {\n  return {\n    originalArg: arg,\n    data: response,\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["While there is less need to store the response in a ",(0,t.jsx)(n.a,{href:"https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape",children:"normalized lookup table"})," with RTK Query managing caching data, ",(0,t.jsx)(n.code,{children:"transformResponse"})," can be leveraged to do so if desired."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Normalize the response data" no-transpile',children:"transformResponse: (response) =>\n  response.reduce((acc, curr) => {\n    acc[curr.id] = curr\n    return acc\n  }, {})\n\n/*\n  will convert:\n  [\n    {id: 1, name: 'Harry'},\n    {id: 2, name: 'Ron'},\n    {id: 3, name: 'Hermione'},\n  ]\n\n  to:\n  {\n    1: { id: 1, name: \"Harry\" },\n    2: { id: 2, name: \"Ron\" },\n    3: { id: 3, name: \"Hermione\" },\n  }\n*/\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/api/createEntityAdapter",children:(0,t.jsx)(n.code,{children:"createEntityAdapter"})})," can also be used with ",(0,t.jsx)(n.code,{children:"transformResponse"})," to normalize data, while also taking advantage of other features provided by ",(0,t.jsx)(n.code,{children:"createEntityAdapter"}),", including providing an ",(0,t.jsx)(n.code,{children:"ids"})," array, using ",(0,t.jsx)(n.a,{href:"/api/createEntityAdapter#sortcomparer",children:(0,t.jsx)(n.code,{children:"sortComparer"})})," to maintain a consistently sorted list, as well as maintaining strong TypeScript support."]}),"\n",(0,t.jsxs)(n.p,{children:["See also ",(0,t.jsx)(n.a,{href:"/rtk-query/usage/streaming-updates#websocket-chat-api-with-a-transformed-response-shape",children:"Websocket Chat API with a transformed response shape"})," for an example of ",(0,t.jsx)(n.code,{children:"transformResponse"})," normalizing response data in combination with ",(0,t.jsx)(n.code,{children:"createEntityAdapter"}),", while also updating further data using ",(0,t.jsx)(n.a,{href:"/rtk-query/usage/streaming-updates",children:(0,t.jsx)(n.code,{children:"streaming updates"})}),"."]}),"\n",(0,t.jsxs)(n.h2,{id:"customizing-query-responses-with-transformerrorresponse",children:["Customizing query responses with ",(0,t.jsx)(n.code,{children:"transformErrorResponse"})]}),"\n",(0,t.jsxs)(n.p,{children:["Individual endpoints on ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi",children:(0,t.jsx)(n.code,{children:"createApi"})})," accept a ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi",children:(0,t.jsx)(n.code,{children:"transformErrorResponse"})})," property which allows manipulation of the error returned by a query or mutation before it hits the cache."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"transformErrorResponse"})," is called with the error that a failed ",(0,t.jsx)(n.code,{children:"baseQuery"})," returns for the corresponding endpoint, and the return value of ",(0,t.jsx)(n.code,{children:"transformErrorResponse"})," is used as the cached error associated with that endpoint call."]}),"\n",(0,t.jsx)(n.p,{children:"By default, the payload from the server is returned directly."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function defaultTransformResponse(\n  baseQueryReturnValue: unknown,\n  meta: unknown,\n  arg: unknown,\n) {\n  return baseQueryReturnValue\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"To change it, provide a function that looks like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Unpack a deeply nested error object" no-transpile',children:"transformErrorResponse: (response, meta, arg) =>\n  response.data.some.deeply.nested.errorObject\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"transformErrorResponse"})," is called with the ",(0,t.jsx)(n.code,{children:"meta"})," property returned from the ",(0,t.jsx)(n.code,{children:"baseQuery"})," as its second\nargument, which can be used while determining the transformed response. The value for ",(0,t.jsx)(n.code,{children:"meta"})," is\ndependent on the ",(0,t.jsx)(n.code,{children:"baseQuery"})," used."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="transformErrorResponse meta example" no-transpile',children:"transformErrorResponse: (\n  response: { data: { sideA: Tracks; sideB: Tracks } },\n  meta,\n  arg,\n) => {\n  if (meta?.coinFlip === 'heads') {\n    return response.data.sideA\n  }\n  return response.data.sideB\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"transformErrorResponse"})," is called with the ",(0,t.jsx)(n.code,{children:"arg"})," property provided to the endpoint as its third\nargument, which can be used while determining the transformed response. The value for ",(0,t.jsx)(n.code,{children:"arg"})," is\ndependent on the ",(0,t.jsx)(n.code,{children:"endpoint"})," used, as well as the argument used when calling the query/mutation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="transformErrorResponse arg example" no-transpile',children:"transformErrorResponse: (response: Posts, meta, arg) => {\n  return {\n    originalArg: arg,\n    error: response,\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"customizing-queries-with-queryfn",children:["Customizing queries with ",(0,t.jsx)(n.code,{children:"queryFn"})]}),"\n",(0,t.jsxs)(n.p,{children:["RTK Query comes with ",(0,t.jsx)(n.code,{children:"fetchBaseQuery"})," out of the box, which makes it straightforward to define endpoints that talk to HTTP URLs (such as a typical REST API). We also have integrations with GraphQL as well. However, at its core, RTK Query is really about tracking loading state and cached values for ",(0,t.jsx)(n.em,{children:"any"})," async request/response sequence, not just HTTP requests."]}),"\n",(0,t.jsxs)(n.p,{children:["RTK Query supports defining endpoints that run arbitrary async logic and return a result. Individual endpoints on ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi",children:(0,t.jsx)(n.code,{children:"createApi"})})," accept a ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#queryfn",children:(0,t.jsx)(n.code,{children:"queryFn"})})," property, which let you write your own async function with whatever logic you want inside."]}),"\n",(0,t.jsx)(n.p,{children:"This can be useful for scenarios where you want to have particularly different behaviour for a single endpoint, or where the query itself is not relevant, including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"One-off queries that use a different base URL"}),"\n",(0,t.jsx)(n.li,{children:"One-off queries that use different request handling, such as automatic re-tries"}),"\n",(0,t.jsx)(n.li,{children:"One-off queries that use different error handling behaviour"}),"\n",(0,t.jsx)(n.li,{children:"Queries that make requests using a third-party library SDK, such as Firebase or Supabase"}),"\n",(0,t.jsx)(n.li,{children:"Queries that perform async tasks that are not a typical request/response"}),"\n",(0,t.jsxs)(n.li,{children:["Performing multiple requests with a single query (",(0,t.jsx)(n.a,{href:"#performing-multiple-requests-with-a-single-query",children:"example"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Leveraging invalidation behaviour with no relevant query (",(0,t.jsx)(n.a,{href:"#using-a-no-op-queryfn",children:"example"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Using ",(0,t.jsx)(n.a,{href:"./streaming-updates",children:"Streaming Updates"})," with no relevant initial request (",(0,t.jsx)(n.a,{href:"#streaming-data-with-no-initial-request",children:"example"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["See also ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#queryfn",children:(0,t.jsx)(n.code,{children:"queryFn API Reference"})})," for the type signature and available options."]}),"\n",(0,t.jsxs)(n.h3,{id:"implementing-a-queryfn",children:["Implementing a ",(0,t.jsx)(n.code,{children:"queryFn"})]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"queryFn"})," can be thought of as an inline ",(0,t.jsx)(n.code,{children:"baseQuery"}),". It will be called with the same arguments as ",(0,t.jsx)(n.code,{children:"baseQuery"}),", as well as the provided ",(0,t.jsx)(n.code,{children:"baseQuery"})," function itself (",(0,t.jsx)(n.code,{children:"arg"}),", ",(0,t.jsx)(n.code,{children:"api"}),", ",(0,t.jsx)(n.code,{children:"extraOptions"}),", and ",(0,t.jsx)(n.code,{children:"baseQuery"}),"). Similarly to ",(0,t.jsx)(n.code,{children:"baseQuery"}),", it is expected to return an object with either a ",(0,t.jsx)(n.code,{children:"data"})," or ",(0,t.jsx)(n.code,{children:"error"})," property, or a promise that resolves to return such an object."]}),"\n",(0,t.jsxs)(n.h4,{id:"basic-queryfn-example",children:["Basic ",(0,t.jsx)(n.code,{children:"queryFn"})," Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Basic queryFn example" no-transpile',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { userAPI, User } from './userAPI'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ url: '/' }),\n  endpoints: (build) => ({\n    // normal HTTP endpoint using fetchBaseQuery\n    getPosts: build.query<PostsResponse, void>({\n      query: () => ({ url: 'posts' }),\n    }),\n    // highlight-start\n    // endpoint with a custom `queryFn` and separate async logic\n    getUser: build.query<User, string>({\n      queryFn: async (userId: string) => {\n        try {\n          const user = await userApi.getUserById(userId)\n          // Return the result in an object with a `data` field\n          return { data: user }\n        } catch (error) {\n          // Catch any errors and return them as an object with an `error` field\n          return { error }\n        }\n      },\n    }),\n    // highlight-end\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h4,{id:"queryfn-function-arguments",children:"queryFn function arguments"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="queryFn example arguments" no-transpile',children:"const queryFn = (\n  // highlight-start\n  args,\n  { signal, dispatch, getState },\n  extraOptions,\n  baseQuery,\n  // highlight-end\n) => {\n  // omitted\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"queryfn-function-return-value",children:"queryFn function return value"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected success result format" no-transpile',children:"return { data: YourData }\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected error result format" no-transpile',children:"return { error: YourError }\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="queryFn example return value" no-transpile',children:"const queryFn = (\n  args,\n  { signal, dispatch, getState },\n  extraOptions,\n  baseQuery,\n) => {\n  // highlight-start\n  if (Math.random() > 0.5) return { error: 'Too high!' }\n  return { data: 'All good!' }\n  // highlight-end\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"examples---basequery",children:["Examples - ",(0,t.jsx)(n.code,{children:"baseQuery"})]}),"\n",(0,t.jsx)(n.h3,{id:"axios-basequery",children:"Axios baseQuery"}),"\n",(0,t.jsxs)(n.p,{children:["This example implements a very basic axios-based ",(0,t.jsx)(n.code,{children:"baseQuery"})," utility."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Basic axios baseQuery"',children:"import { createApi } from '@reduxjs/toolkit/query'\nimport type { BaseQueryFn } from '@reduxjs/toolkit/query'\nimport axios from 'axios'\nimport type { AxiosRequestConfig, AxiosError } from 'axios'\n\n// highlight-start\nconst axiosBaseQuery =\n  (\n    { baseUrl }: { baseUrl: string } = { baseUrl: '' },\n  ): BaseQueryFn<\n    {\n      url: string\n      method?: AxiosRequestConfig['method']\n      data?: AxiosRequestConfig['data']\n      params?: AxiosRequestConfig['params']\n      headers?: AxiosRequestConfig['headers']\n    },\n    unknown,\n    unknown\n  > =>\n  async ({ url, method, data, params, headers }) => {\n    try {\n      const result = await axios({\n        url: baseUrl + url,\n        method,\n        data,\n        params,\n        headers,\n      })\n      return { data: result.data }\n    } catch (axiosError) {\n      const err = axiosError as AxiosError\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n        },\n      }\n    }\n  }\n// highlight-end\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: axiosBaseQuery({\n    baseUrl: 'https://example.com',\n  }),\n  // highlight-end\n  endpoints(build) {\n    return {\n      query: build.query({ query: () => ({ url: '/query', method: 'get' }) }),\n      mutation: build.mutation({\n        query: () => ({ url: '/mutation', method: 'post' }),\n      }),\n    }\n  },\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"graphql-basequery",children:"GraphQL baseQuery"}),"\n",(0,t.jsxs)(n.p,{children:["This example implements a very basic GraphQL-based ",(0,t.jsx)(n.code,{children:"baseQuery"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Basic GraphQL baseQuery"',children:"import { createApi } from '@reduxjs/toolkit/query'\nimport { request, gql, ClientError } from 'graphql-request'\n\n// highlight-start\nconst graphqlBaseQuery =\n  ({ baseUrl }: { baseUrl: string }) =>\n  async ({ body }: { body: string }) => {\n    try {\n      const result = await request(baseUrl, body)\n      return { data: result }\n    } catch (error) {\n      if (error instanceof ClientError) {\n        return { error: { status: error.response.status, data: error } }\n      }\n      return { error: { status: 500, data: error } }\n    }\n  }\n// highlight-end\n\nexport const api = createApi({\n  // highlight-start\n  baseQuery: graphqlBaseQuery({\n    baseUrl: 'https://graphqlzero.almansi.me/api',\n  }),\n  // highlight-end\n  endpoints: (builder) => ({\n    getPosts: builder.query({\n      query: () => ({\n        body: gql`\n          query {\n            posts {\n              data {\n                id\n                title\n              }\n            }\n          }\n        `,\n      }),\n      transformResponse: (response) => response.posts.data,\n    }),\n    getPost: builder.query({\n      query: (id) => ({\n        body: gql`\n        query {\n          post(id: ${id}) {\n            id\n            title\n            body\n          }\n        }\n        `,\n      }),\n      transformResponse: (response) => response.post,\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"automatic-re-authorization-by-extending-fetchbasequery",children:"Automatic re-authorization by extending fetchBaseQuery"}),"\n",(0,t.jsxs)(n.p,{children:["This example wraps ",(0,t.jsx)(n.a,{href:"../api/fetchBaseQuery",children:(0,t.jsx)(n.code,{children:"fetchBaseQuery"})})," such that when encountering a ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401",children:(0,t.jsx)(n.code,{children:"401 Unauthorized"})})," error, an additional request is sent to attempt to refresh an authorization token, and re-try to initial query after re-authorizing."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Simulating axios-like interceptors with a custom base query"',children:"// file: authSlice.ts noEmit\ndeclare function tokenReceived(args?: any): void\ndeclare function loggedOut(): void\nexport { tokenReceived, loggedOut }\n// file: baseQueryWithReauth.ts\nimport { fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\n\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    // try to get a new token\n    const refreshResult = await baseQuery('/refreshToken', api, extraOptions)\n    if (refreshResult.data) {\n      // store the new token\n      api.dispatch(tokenReceived(refreshResult.data))\n      // retry the initial query\n      result = await baseQuery(args, api, extraOptions)\n    } else {\n      api.dispatch(loggedOut())\n    }\n  }\n  return result\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"preventing-multiple-unauthorized-errors",children:"Preventing multiple unauthorized errors"}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.a,{href:"https://github.com/DirtyHairy/async-mutex",children:(0,t.jsx)(n.code,{children:"async-mutex"})})," to prevent multiple calls to '/refreshToken' when multiple calls fail with ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401",children:(0,t.jsx)(n.code,{children:"401 Unauthorized"})})," errors."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"title=\"Preventing multiple calls to '/refreshToken'\"",children:"// file: authSlice.ts noEmit\ndeclare function tokenReceived(args?: any): void\ndeclare function loggedOut(): void\nexport { tokenReceived, loggedOut }\n// file: baseQueryWithReauth.ts\n\nimport { fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\n// highlight-start\nimport { Mutex } from 'async-mutex'\n// highlight-end\n\n// create a new mutex\n// highlight-start\nconst mutex = new Mutex()\n// highlight-end\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  // wait until the mutex is available without locking it\n  // highlight-start\n  await mutex.waitForUnlock()\n  // highlight-end\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    // checking whether the mutex is locked\n    // highlight-start\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire()\n      // highlight-end\n      try {\n        const refreshResult = await baseQuery(\n          '/refreshToken',\n          api,\n          extraOptions,\n        )\n        if (refreshResult.data) {\n          api.dispatch(tokenReceived(refreshResult.data))\n          // retry the initial query\n          result = await baseQuery(args, api, extraOptions)\n        } else {\n          api.dispatch(loggedOut())\n        }\n      } finally {\n        // release must be called once the mutex should be released again.\n        // highlight-start\n        release()\n        // highlight-end\n      }\n    } else {\n      // wait until the mutex is available without locking it\n      // highlight-start\n      await mutex.waitForUnlock()\n      // highlight-end\n      result = await baseQuery(args, api, extraOptions)\n    }\n  }\n  return result\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"automatic-retries",children:"Automatic retries"}),"\n",(0,t.jsxs)(n.p,{children:["RTK Query exports a utility called ",(0,t.jsx)(n.code,{children:"retry"})," that you can wrap the ",(0,t.jsx)(n.code,{children:"baseQuery"})," in your API definition with. It defaults to 5 attempts with a basic exponential backoff."]}),"\n",(0,t.jsx)(n.p,{children:"The default behavior would retry at these intervals:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"600ms * random(0.4, 1.4)"}),"\n",(0,t.jsx)(n.li,{children:"1200ms * random(0.4, 1.4)"}),"\n",(0,t.jsx)(n.li,{children:"2400ms * random(0.4, 1.4)"}),"\n",(0,t.jsx)(n.li,{children:"4800ms * random(0.4, 1.4)"}),"\n",(0,t.jsx)(n.li,{children:"9600ms * random(0.4, 1.4)"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Retry every request 5 times by default"',children:"import { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\n// maxRetries: 5 is the default, and can be omitted. Shown for documentation purposes.\nconst staggeredBaseQuery = retry(fetchBaseQuery({ baseUrl: '/' }), { maxRetries: 5 });\nexport const api = createApi({\n  baseQuery: staggeredBaseQuery,\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => ({ url: 'posts' }),\n    }),\n    getPost: build.query<PostsResponse, string>({\n      query: (id) => ({ url: `post/${id}` }),\n      extraOptions: { maxRetries: 8 }, // You can override the retry behavior on each endpoint\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery, useGetPostQuery } = api;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the event that you didn't want to retry on a specific endpoint, you can just set ",(0,t.jsx)(n.code,{children:"maxRetries: 0"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["It is possible for a hook to return ",(0,t.jsx)(n.code,{children:"data"})," and ",(0,t.jsx)(n.code,{children:"error"})," at the same time. By default, RTK Query will keep whatever the last 'good' result was in ",(0,t.jsx)(n.code,{children:"data"})," until it can be updated or garbage collected."]})}),"\n",(0,t.jsx)(n.h4,{id:"bailing-out-of-error-re-tries",children:"Bailing out of error re-tries"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"retry"})," utility has a ",(0,t.jsx)(n.code,{children:"fail"})," method property attached which can be used to bail out of retries immediately. This can be used for situations where it is known that additional re-tries would be guaranteed to all fail and would be redundant."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Bailing out of error re-tries"',children:"import { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react'\nimport type { FetchArgs } from '@reduxjs/toolkit/query'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\n// highlight-start\nconst staggeredBaseQueryWithBailOut = retry(\n  async (args: string | FetchArgs, api, extraOptions) => {\n    const result = await fetchBaseQuery({ baseUrl: '/api/' })(\n      args,\n      api,\n      extraOptions,\n    )\n\n    // bail out of re-tries immediately if unauthorized,\n    // because we know successive re-retries would be redundant\n    if (result.error?.status === 401) {\n      retry.fail(result.error)\n    }\n\n    return result\n  },\n  {\n    maxRetries: 5,\n  },\n)\n// highlight-end\n\nexport const api = createApi({\n  // highlight-start\n  baseQuery: staggeredBaseQueryWithBailOut,\n  // highlight-end\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => ({ url: 'posts' }),\n    }),\n    getPost: build.query<Post, string>({\n      query: (id) => ({ url: `post/${id}` }),\n      extraOptions: { maxRetries: 8 }, // You can override the retry behavior on each endpoint\n    }),\n  }),\n})\nexport const { useGetPostsQuery, useGetPostQuery } = api\n"})}),"\n",(0,t.jsx)(n.h3,{id:"adding-meta-information-to-queries",children:"Adding Meta information to queries"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"baseQuery"})," can also include a ",(0,t.jsx)(n.code,{children:"meta"})," property in its return value. This can be beneficial in cases where you may wish to include additional information associated with the request such as a request ID or timestamp."]}),"\n",(0,t.jsx)(n.p,{children:"In such a scenario, the return value would look like so:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected success result format with meta" no-transpile',children:"return { data: YourData, meta: YourMeta }\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Expected error result format with meta" no-transpile',children:"return { error: YourError, meta: YourMeta }\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="baseQuery example with meta information"',children:"// file: idGenerator.ts noEmit\nexport declare const uuid: () => string\n\n// file: metaBaseQuery.ts\nimport { fetchBaseQuery, createApi } from '@reduxjs/toolkit/query'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport type { FetchBaseQueryMeta } from '@reduxjs/toolkit/dist/query/fetchBaseQuery'\nimport { uuid } from './idGenerator'\n\n// highlight-start\ntype Meta = {\n  requestId: string\n  timestamp: number\n}\n// highlight-end\n\n// highlight-start\nconst metaBaseQuery: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError,\n  {},\n  Meta & FetchBaseQueryMeta\n> = async (args, api, extraOptions) => {\n  const requestId = uuid()\n  const timestamp = Date.now()\n\n  const baseResult = await fetchBaseQuery({ baseUrl: '/' })(\n    args,\n    api,\n    extraOptions,\n  )\n\n  return {\n    ...baseResult,\n    meta: baseResult.meta && { ...baseResult.meta, requestId, timestamp },\n  }\n}\n// highlight-end\n\nconst DAY_MS = 24 * 60 * 60 * 1000\n\ninterface Post {\n  id: number\n  name: string\n  timestamp: number\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: metaBaseQuery,\n  // highlight-end\n  endpoints: (build) => ({\n    // a theoretical endpoint where we only want to return data\n    // if request was performed past a certain date\n    getRecentPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      transformResponse: (returnValue: PostsResponse, meta) => {\n        // `meta` here contains our added `requestId` & `timestamp`, as well as\n        // `request` & `response` from fetchBaseQuery's meta object.\n        // These properties can be used to transform the response as desired.\n        if (!meta) return []\n        return returnValue.filter(\n          (post) => post.timestamp >= meta.timestamp - DAY_MS,\n        )\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"constructing-a-dynamic-base-url-using-redux-state",children:"Constructing a Dynamic Base URL using Redux state"}),"\n",(0,t.jsxs)(n.p,{children:["In some cases, you may wish to have a dynamically altered base url determined from a property in your Redux state. A ",(0,t.jsx)(n.code,{children:"baseQuery"})," has access to a ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#basequery-function-arguments",children:(0,t.jsx)(n.code,{children:"getState"})})," method that provides the current store state at the time it is called. This can be used to construct the desired url using a partial url string, and the appropriate data from your store state."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Dynamically generated Base URL example"',children:"// file: src/store.ts noEmit\nexport type RootState = {\n  auth: {\n    projectId: number | null\n  }\n}\n\n// file: src/services/projectSlice.ts noEmit\nimport type { RootState } from '../store'\nexport const selectProjectId = (state: RootState) => state.auth.projectId\n\n// file: src/services/types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\n// file: src/services/api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query/react'\nimport type { Post } from './types'\nimport { selectProjectId } from './projectSlice'\nimport type { RootState } from '../store'\n\nconst rawBaseQuery = fetchBaseQuery({\n  baseUrl: 'www.my-cool-site.com/',\n})\n\nconst dynamicBaseQuery: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  const projectId = selectProjectId(api.getState() as RootState)\n  // gracefully handle scenarios where data to generate the URL is missing\n  if (!projectId) {\n    return {\n      error: {\n        status: 400,\n        statusText: 'Bad Request',\n        data: 'No project ID received',\n      },\n    }\n  }\n\n  const urlEnd = typeof args === 'string' ? args : args.url\n  // construct a dynamically generated portion of the url\n  const adjustedUrl = `project/${projectId}/${urlEnd}`\n  const adjustedArgs =\n    typeof args === 'string' ? adjustedUrl : { ...args, url: adjustedUrl }\n  // provide the amended url and other params to the raw base query\n  return rawBaseQuery(adjustedArgs, api, extraOptions)\n}\n\nexport const api = createApi({\n  baseQuery: dynamicBaseQuery,\n  endpoints: (builder) => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => 'posts',\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery } = api\n\n/*\n  Using `useGetPostsQuery()` where a `projectId` of 500 is in the redux state will result in\n  a request being sent to www.my-cool-site.com/project/500/posts\n*/\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"examples---transformresponse",children:["Examples - ",(0,t.jsx)(n.code,{children:"transformResponse"})]}),"\n",(0,t.jsx)(n.h3,{id:"unpacking-deeply-nested-graphql-data",children:"Unpacking deeply nested GraphQL data"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="GraphQL transformation example"',children:"// file: graphqlBaseQuery.ts noEmit\nimport { BaseQueryFn } from '@reduxjs/toolkit/query'\ndeclare const graphqlBaseQuery: (args: { baseUrl: string }) => BaseQueryFn\ndeclare const gql: (literals: TemplateStringsArray) => void\nexport { graphqlBaseQuery, gql }\n\n// file: graphqlApi.ts\nimport { createApi } from '@reduxjs/toolkit/query'\nimport { graphqlBaseQuery, gql } from './graphqlBaseQuery'\n\ninterface Post {\n  id: number\n  title: string\n}\n\nexport const api = createApi({\n  baseQuery: graphqlBaseQuery({\n    baseUrl: '/graphql',\n  }),\n  endpoints: (builder) => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => ({\n        body: gql`\n          query {\n            posts {\n              data {\n                id\n                title\n              }\n            }\n          }\n        `,\n      }),\n      // highlight-start\n      transformResponse: (response: { posts: { data: Post[] } }) =>\n        response.posts.data,\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"normalizing-data-with-createentityadapter",children:["Normalizing data with ",(0,t.jsx)(n.code,{children:"createEntityAdapter"})]}),"\n",(0,t.jsxs)(n.p,{children:["In the example below, ",(0,t.jsx)(n.code,{children:"transformResponse"})," is used in conjunction with ",(0,t.jsx)(n.a,{href:"/api/createEntityAdapter",children:(0,t.jsx)(n.code,{children:"createEntityAdapter"})})," to normalize the data before storing it in the cache."]}),"\n",(0,t.jsx)(n.p,{children:"For a response such as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"[\n  { id: 1, name: 'Harry' },\n  { id: 2, name: 'Ron' },\n  { id: 3, name: 'Hermione' },\n]\n"})}),"\n",(0,t.jsx)(n.p,{children:"The normalized cache data will be stored as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'{\n  ids: [1, 3, 2],\n  entities: {\n    1: { id: 1, name: "Harry" },\n    2: { id: 2, name: "Ron" },\n    3: { id: 3, name: "Hermione" },\n  }\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { createEntityAdapter } from '@reduxjs/toolkit'\nimport type { EntityState } from '@reduxjs/toolkit'\n\nexport interface Post {\n  id: number\n  name: string\n}\n\n// highlight-start\nconst postsAdapter = createEntityAdapter<Post>({\n  sortComparer: (a, b) => a.name.localeCompare(b.name),\n})\n// highlight-end\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<EntityState<Post, number>, void>({\n      query: () => `posts`,\n      // highlight-start\n      transformResponse(response: Post[]) {\n        return postsAdapter.addMany(postsAdapter.getInitialState(), response)\n      },\n      // highlight-end\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery } = api\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"examples---queryfn",children:["Examples - ",(0,t.jsx)(n.code,{children:"queryFn"})]}),"\n",(0,t.jsx)(n.h3,{id:"using-a-third-party-sdk",children:"Using a Third-Party SDK"}),"\n",(0,t.jsxs)(n.p,{children:["Many services like Firebase and Supabase provide their own SDK to make requests. You can use those SDK methods in a ",(0,t.jsx)(n.code,{children:"queryFn"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Basic Third-Party SDK" no-transpile',children:"import { createApi, fakeBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { supabase } from './supabaseApi'\n\nexport const supabaseApi = createApi({\n  reducerPath: 'supabaseApi',\n  baseQuery: fakeBaseQuery(),\n  endpoints: (builder) => ({\n    getBlogs: builder.query({\n      queryFn: async () => {\n        // Supabase conveniently already has `data` and `error` fields\n        const { data, error } = await supabase.from('blogs').select()\n        if (error) {\n          return { error }\n        }\n        return { data }\n      },\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"You could also try creating a custom base query that uses the SDK, and define endpoints that pass method names or args into that base query."}),"\n",(0,t.jsx)(n.h3,{id:"using-a-no-op-queryfn",children:"Using a no-op queryFn"}),"\n",(0,t.jsxs)(n.p,{children:["In certain scenarios, you may wish to have a ",(0,t.jsx)(n.code,{children:"query"})," or ",(0,t.jsx)(n.code,{children:"mutation"})," where sending a request or returning data is not relevant for the situation. Such a scenario would be to leverage the ",(0,t.jsx)(n.code,{children:"invalidatesTags"})," property to force re-fetch specific ",(0,t.jsx)(n.code,{children:"tags"})," that have been provided to the cache."]}),"\n",(0,t.jsxs)(n.p,{children:["See also ",(0,t.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching#providing-data-to-the-cache",children:(0,t.jsx)(n.code,{children:"providing errors to the cache"})})," to see additional detail and an example for such a scenario to 'refetch errored queries'."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Using a no-op queryFn"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => 'posts',\n      providesTags: ['Post'],\n    }),\n\n    getUsers: build.query<User[], void>({\n      query: () => 'users',\n      providesTags: ['User'],\n    }),\n\n    // highlight-start\n    refetchPostsAndUsers: build.mutation<null, void>({\n      // The query is not relevant here, so a `null` returning `queryFn` is used\n      queryFn: () => ({ data: null }),\n      // This mutation takes advantage of tag invalidation behaviour to trigger\n      // any queries that provide the 'Post' or 'User' tags to re-fetch if the queries\n      // are currently subscribed to the cached data\n      invalidatesTags: ['Post', 'User'],\n    }),\n    // highlight-end\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"streaming-data-with-no-initial-request",children:"Streaming data with no initial request"}),"\n",(0,t.jsxs)(n.p,{children:["RTK Query provides the ability for an endpoint to send an initial request for data, followed up with recurring ",(0,t.jsx)(n.a,{href:"/rtk-query/usage/streaming-updates",children:"streaming updates"})," that perform further updates to the cached data as the updates occur. However, the initial request is optional, and you may wish to use streaming updates without any initial request fired off."]}),"\n",(0,t.jsxs)(n.p,{children:["In the example below, a ",(0,t.jsx)(n.code,{children:"queryFn"})," is used to populate the cache data with an empty array, with no initial request sent. The array is later populated using streaming updates via the ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#oncacheentryadded",children:(0,t.jsx)(n.code,{children:"onCacheEntryAdded"})})," endpoint option, updating the cached data as it is received."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Streaming data with no initial request"',children:"// file: types.ts noEmit\nexport interface Message {\n  id: number\n  channel: 'general' | 'redux'\n  userName: string\n  text: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Message } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Message'],\n  endpoints: (build) => ({\n    // highlight-start\n    streamMessages: build.query<Message[], void>({\n      // The query is not relevant here as the data will be provided via streaming updates.\n      // A queryFn returning an empty array is used, with contents being populated via\n      // streaming updates below as they are received.\n      queryFn: () => ({ data: [] }),\n      async onCacheEntryAdded(arg, { updateCachedData, cacheEntryRemoved }) {\n        const ws = new WebSocket('ws://localhost:8080')\n        // populate the array with messages as they are received from the websocket\n        ws.addEventListener('message', (event) => {\n          updateCachedData((draft) => {\n            draft.push(JSON.parse(event.data))\n          })\n        })\n        await cacheEntryRemoved\n        ws.close()\n      },\n    }),\n    // highlight-end\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"performing-multiple-requests-with-a-single-query",children:"Performing multiple requests with a single query"}),"\n",(0,t.jsxs)(n.p,{children:["In the example below, a query is written to fetch all posts for a random user. This is done using a first request for a random user, followed by getting all posts for that user. Using ",(0,t.jsx)(n.code,{children:"queryFn"})," allows the two requests to be included within a single query, avoiding having to chain that logic within component code."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Performing multiple requests with a single query"',children:"// file: types.ts noEmit\nexport interface Post {}\nexport interface User {\n  id: number\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { FetchBaseQueryError } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/ ' }),\n  endpoints: (build) => ({\n    getRandomUserPosts: build.query<Post, void>({\n      async queryFn(_arg, _queryApi, _extraOptions, fetchWithBQ) {\n        // get a random user\n        const randomResult = await fetchWithBQ('users/random')\n        if (randomResult.error)\n          return { error: randomResult.error as FetchBaseQueryError }\n        const user = randomResult.data as User\n        const result = await fetchWithBQ(`user/${user.id}/posts`)\n        return result.data\n          ? { data: result.data as Post }\n          : { error: result.error as FetchBaseQueryError }\n      },\n    }),\n  }),\n})\n"})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);