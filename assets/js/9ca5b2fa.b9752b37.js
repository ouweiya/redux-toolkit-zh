"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[2646],{7064:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=n(4848),s=n(8453);const o={id:"endpoints",title:"API Slices: Endpoints",sidebar_label:"Endpoints",hide_title:!0},a="API Slices: Endpoints",r={id:"rtk-query/api/created-api/endpoints",title:"API Slices: Endpoints",description:"&nbsp;",source:"@site/docs/rtk-query/api/created-api/endpoints.mdx",sourceDirName:"rtk-query/api/created-api",slug:"/rtk-query/api/created-api/endpoints",permalink:"/rtk-query/api/created-api/endpoints",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rtk-query/api/created-api/endpoints.mdx",tags:[],version:"current",frontMatter:{id:"endpoints",title:"API Slices: Endpoints",sidebar_label:"Endpoints",hide_title:!0},sidebar:"docs",previous:{title:"Redux Integration",permalink:"/rtk-query/api/created-api/redux-integration"},next:{title:"Code Splitting",permalink:"/rtk-query/api/created-api/code-splitting"}},c={},l=[{value:"<code>initiate</code>",id:"initiate",level:2},{value:"Signature",id:"signature",level:4},{value:"Description",id:"description",level:4},{value:"Example",id:"example",level:4},{value:"<code>select</code>",id:"select",level:2},{value:"Signature",id:"signature-1",level:4},{value:"Description",id:"description-1",level:4},{value:"Example",id:"example-1",level:4},{value:"Matchers",id:"matchers",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h4:"h4",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"\xa0"}),"\n",(0,i.jsx)(t.h1,{id:"api-slices-endpoints",children:"API Slices: Endpoints"}),"\n",(0,i.jsxs)(t.p,{children:["The API slice object will have an ",(0,i.jsx)(t.code,{children:"endpoints"})," field inside. This section maps the endpoint names you provided to ",(0,i.jsx)(t.code,{children:"createApi"})," to the core Redux logic (thunks and selectors) used to trigger data fetches and read cached data for that endpoint. If you're using the React-specific version of ",(0,i.jsx)(t.code,{children:"createApi"}),", each endpoint definition will also contain the auto-generated React hooks for that endpoint."]}),"\n",(0,i.jsx)(t.p,{children:"Each endpoint structure contains the following fields:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"type EndpointLogic = {\n  initiate: InitiateRequestThunk\n  select: CreateCacheSelectorFactory\n  matchPending: Matcher<PendingAction>\n  matchFulfilled: Matcher<FulfilledAction>\n  matchRejected: Matcher<RejectedAction>\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"initiate",children:(0,i.jsx)(t.code,{children:"initiate"})}),"\n",(0,i.jsx)(t.h4,{id:"signature",children:"Signature"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"type InitiateRequestThunk = StartQueryActionCreator | StartMutationActionCreator;\n\ntype StartQueryActionCreator = (\n  arg:any,\n  options?: StartQueryActionCreatorOptions\n) => ThunkAction<QueryActionCreatorResult, any, any, UnknownAction>;\n\ntype StartMutationActionCreator<D extends MutationDefinition<any, any, any, any>> = (\n  arg: any\n  options?: StartMutationActionCreatorOptions\n) => ThunkAction<MutationActionCreatorResult<D>, any, any, UnknownAction>;\n\ntype SubscriptionOptions = {\n  /**\n   * How frequently to automatically re-fetch data (in milliseconds). Defaults to `0` (off).\n   */\n  pollingInterval?: number;\n  /**\n   * Defaults to `false`. This setting allows you to control whether RTK Query will try to refetch all subscribed queries after regaining a network connection.\n   *\n   * If you specify this option alongside `skip: true`, this **will not be evaluated** until `skip` is false.\n   *\n   * Note: requires `setupListeners` to have been called.\n   */\n  refetchOnReconnect?: boolean;\n  /**\n   * Defaults to `false`. This setting allows you to control whether RTK Query will try to refetch all subscribed queries after the application window regains focus.\n   *\n   * If you specify this option alongside `skip: true`, this **will not be evaluated** until `skip` is false.\n   *\n   * Note: requires `setupListeners` to have been called.\n   */\n  refetchOnFocus?: boolean;\n};\n\ninterface StartQueryActionCreatorOptions {\n  subscribe?: boolean;\n  forceRefetch?: boolean | number;\n  subscriptionOptions?: SubscriptionOptions;\n}\n\ninterface StartMutationActionCreatorOptions {\n  /**\n   * If this mutation should be tracked in the store.\n   * If you just want to manually trigger this mutation using `dispatch` and don't care about the\n   * result, state & potential errors being held in store, you can set this to false.\n   * (defaults to `true`)\n   */\n  track?: boolean;\n}\n"})}),"\n",(0,i.jsx)(t.h4,{id:"description",children:"Description"}),"\n",(0,i.jsx)(t.p,{children:"A Redux thunk action creator that you can dispatch to trigger data fetch queries or mutations."}),"\n",(0,i.jsx)(t.p,{children:"React Hooks users will most likely never need to use these directly, as the hooks automatically dispatch these actions as needed."}),"\n",(0,i.jsx)(t.admonition,{title:"Usage of actions outside of React Hooks",type:"note",children:(0,i.jsxs)(t.p,{children:["When dispatching an action creator, you're responsible for storing a reference to the promise it returns in the event that you want to update that specific subscription. Also, you have to manually unsubscribe once your component unmounts. To get an idea of what that entails, see the ",(0,i.jsx)(t.a,{href:"/rtk-query/usage/examples#svelte",children:"Svelte Example"})," or the ",(0,i.jsx)(t.a,{href:"/rtk-query/usage/examples#react-class-components",children:"React Class Components Example"})]})}),"\n",(0,i.jsx)(t.h4,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="initiate query example"',children:"import { useState } from 'react'\nimport { useAppDispatch } from './store/hooks'\nimport { api } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [postId, setPostId] = useState<number>(1)\n\n  useEffect(() => {\n    // highlight-start\n    // Add a subscription\n    const result = dispatch(api.endpoints.getPost.initiate(postId))\n\n    // Return the `unsubscribe` callback to be called in the `useEffect` cleanup step\n    return result.unsubscribe\n    // highlight-end\n  }, [dispatch, postId])\n\n  return (\n    <div>\n      <div>Initiate query example</div>\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="initiate mutation example"',children:"import { useState } from 'react'\nimport { useAppDispatch } from './store/hooks'\nimport { api, Post } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [newPost, setNewPost] = useState<Omit<Post, 'id'>>({ name: 'Ash' })\n\n  function handleClick() {\n    // highlight-start\n    // Trigger a mutation\n    // The `track` property can be set `false` in situations where we aren't\n    // interested in the result of the mutation\n    dispatch(api.endpoints.addPost.initiate(newPost), { track: false })\n    // highlight-end\n  }\n\n  return (\n    <div>\n      <div>Initiate mutation example</div>\n      <button onClick={handleClick}>Add post</button>\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"select",children:(0,i.jsx)(t.code,{children:"select"})}),"\n",(0,i.jsx)(t.h4,{id:"signature-1",children:"Signature"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"type CreateCacheSelectorFactory =\n  | QueryResultSelectorFactory\n  | MutationResultSelectorFactory\n\ntype QueryResultSelectorFactory = (\n  queryArg: QueryArg | SkipToken,\n) => (state: RootState) => QueryResultSelectorResult<Definition>\n\ntype MutationResultSelectorFactory<\n  Definition extends MutationDefinition<any, any, any, any>,\n  RootState,\n> = (\n  requestId: string | SkipToken,\n) => (state: RootState) => MutationSubState<Definition> & RequestStatusFlags\n\ntype SkipToken = typeof Symbol\n"})}),"\n",(0,i.jsx)(t.h4,{id:"description-1",children:"Description"}),"\n",(0,i.jsxs)(t.p,{children:["A function that accepts a cache key argument, and generates a new memoized selector for reading cached data for this endpoint using the given cache key. The generated selector is memoized using ",(0,i.jsxs)(t.a,{href:"https://redux-toolkit.js.org/api/createSelector",children:["Reselect's ",(0,i.jsx)(t.code,{children:"createSelector"})]}),"."]}),"\n",(0,i.jsx)(t.p,{children:"When selecting mutation results rather than queries, the function accepts a request ID instead."}),"\n",(0,i.jsxs)(t.p,{children:["RTKQ defines a ",(0,i.jsx)(t.code,{children:"Symbol"})," named ",(0,i.jsx)(t.code,{children:"skipToken"})," internally. If ",(0,i.jsx)(t.code,{children:"skipToken"})," is passed as the query argument to these selectors, the selector will return a default uninitialized state. This can be used to avoid returning a value if a given query is supposed to be disabled."]}),"\n",(0,i.jsx)(t.p,{children:"React Hooks users will most likely never need to use these directly, as the hooks automatically use these selectors as needed."}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["Each call to ",(0,i.jsx)(t.code,{children:".select(someCacheKey)"})," returns a ",(0,i.jsx)(t.em,{children:"new"})," selector function instance. In order for memoization to work correctly, you should create a given selector function once per cache key and reuse that selector function instance, rather than creating a new selector instance each time."]})}),"\n",(0,i.jsx)(t.h4,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="select query example"',children:"import { useState, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from './store/hooks'\nimport { api } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [postId, setPostId] = useState(1)\n  // highlight-start\n  // useMemo is used to only call `.select()` when required.\n  // Each call will create a new selector function instance\n  const selectPost = useMemo(\n    () => api.endpoints.getPost.select(postId),\n    [postId],\n  )\n  const { data, isLoading } = useAppSelector(selectPost)\n  // highlight-end\n\n  useEffect(() => {\n    // Add a subscription\n    const result = dispatch(api.endpoints.getPost.initiate(postId))\n\n    // Return the `unsubscribe` callback to be called in the cleanup step\n    return result.unsubscribe\n  }, [dispatch, postId])\n\n  if (isLoading) return <div>Loading post...</div>\n\n  return (\n    <div>\n      <div>Initiate query example</div>\n      <div>Post name: {data.name}</div>\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="select mutation example"',children:"import { useState, useMemo } from 'react'\nimport { skipToken } from '@reduxjs/toolkit/query'\nimport { useAppDispatch, useAppSelector } from './store/hooks'\nimport { api } from './services/api'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n  const [newPost, setNewPost] = useState({ name: 'Ash' })\n  const [requestId, setRequestId] = useState<typeof skipToken | string>(\n    skipToken,\n  )\n  // highlight-start\n  // useMemo is used to only call `.select(..)` when required.\n  // Each call will create a new selector function instance\n  const selectMutationResult = useMemo(\n    () => api.endpoints.addPost.select(requestId),\n    [requestId],\n  )\n  const { isLoading } = useAppSelector(selectMutationResult)\n  // highlight-end\n\n  function handleClick() {\n    // Trigger a mutation\n    const result = dispatch(api.endpoints.addPost.initiate(newPost))\n    // store the requestId to select the mutation result elsewhere\n    setRequestId(result.requestId)\n  }\n\n  if (isLoading) return <div>Adding post...</div>\n\n  return (\n    <div>\n      <div>Select mutation example</div>\n      <button onClick={handleClick}>Add post</button>\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"matchers",children:"Matchers"}),"\n",(0,i.jsxs)(t.p,{children:["A set of ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/api/matching-utilities",children:"Redux Toolkit action matching utilities"})," that match the ",(0,i.jsx)(t.code,{children:"pending"}),", ",(0,i.jsx)(t.code,{children:"fulfilled"}),", and ",(0,i.jsx)(t.code,{children:"rejected"})," actions that will be dispatched by this thunk. These allow you to match on Redux actions for that endpoint, such as in ",(0,i.jsx)(t.code,{children:"createSlice.extraReducers"})," or a custom middleware. Those are implemented as follows:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:" matchPending: isAllOf(isPending(thunk), matchesEndpoint(endpoint)),\n matchFulfilled: isAllOf(isFulfilled(thunk), matchesEndpoint(endpoint)),\n matchRejected: isAllOf(isRejected(thunk), matchesEndpoint(endpoint)),\n"})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);