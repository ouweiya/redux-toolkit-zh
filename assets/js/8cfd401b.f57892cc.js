"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[9275],{8444:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>A,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(4848),s=n(8453);const i={id:"immer-reducers",title:"Writing Reducers with Immer",sidebar_label:"Writing Reducers with Immer",hide_title:!0},r="Writing Reducers with Immer",o={id:"usage/immer-reducers",title:"Writing Reducers with Immer",description:"&nbsp;",source:"@site/docs/usage/immer-reducers.md",sourceDirName:"usage",slug:"/usage/immer-reducers",permalink:"/usage/immer-reducers",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usage/immer-reducers.md",tags:[],version:"current",frontMatter:{id:"immer-reducers",title:"Writing Reducers with Immer",sidebar_label:"Writing Reducers with Immer",hide_title:!0},sidebar:"docs",previous:{title:"Usage With TypeScript",permalink:"/usage/usage-with-typescript"},next:{title:"Setup with Next.js",permalink:"/usage/nextjs"}},A={},d=[{value:"Immutability and Redux",id:"immutability-and-redux",level:2},{value:"Basics of Immutability",id:"basics-of-immutability",level:3},{value:"Reducers and Immutable Updates",id:"reducers-and-immutable-updates",level:3},{value:"Immutable Updates with Immer",id:"immutable-updates-with-immer",level:2},{value:"Redux Toolkit and Immer",id:"redux-toolkit-and-immer",level:3},{value:"Immer Usage Patterns",id:"immer-usage-patterns",level:2},{value:"Mutating and Returning State",id:"mutating-and-returning-state",level:3},{value:"Resetting and Replacing State",id:"resetting-and-replacing-state",level:3},{value:"Debugging and Inspecting Drafted State",id:"debugging-and-inspecting-drafted-state",level:3},{value:"Updating Nested Data",id:"updating-nested-data",level:3},{value:"Linting State Mutations",id:"linting-state-mutations",level:3},{value:"Why Immer is Built In",id:"why-immer-is-built-in",level:2},{value:"Benefits of Immer",id:"benefits-of-immer",level:3},{value:"Tradeoffs and Concerns",id:"tradeoffs-and-concerns",level:3},{value:"Architecture and Intent",id:"architecture-and-intent",level:3},{value:"Further Information",id:"further-information",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"\xa0"}),"\n",(0,a.jsx)(t.h1,{id:"writing-reducers-with-immer",children:"Writing Reducers with Immer"}),"\n",(0,a.jsxs)(t.p,{children:["Redux Toolkit's ",(0,a.jsx)(t.a,{href:"/api/createReducer",children:(0,a.jsx)(t.code,{children:"createReducer"})})," and ",(0,a.jsx)(t.a,{href:"/api/createSlice",children:(0,a.jsx)(t.code,{children:"createSlice"})})," automatically use ",(0,a.jsx)(t.a,{href:"https://immerjs.github.io/immer/",children:"Immer"}),' internally to let you write simpler immutable update logic using "mutating" syntax. This helps simplify most reducer implementations.']}),"\n",(0,a.jsx)(t.p,{children:"Because Immer is itself an abstraction layer, it's important to understand why Redux Toolkit uses Immer, and how to use it correctly."}),"\n",(0,a.jsx)(t.h2,{id:"immutability-and-redux",children:"Immutability and Redux"}),"\n",(0,a.jsx)(t.h3,{id:"basics-of-immutability",children:"Basics of Immutability"}),"\n",(0,a.jsx)(t.p,{children:'"Mutable" means "changeable". If something is "immutable", it can never be changed.'}),"\n",(0,a.jsx)(t.p,{children:"JavaScript objects and arrays are all mutable by default. If I create an object, I can change the contents of its fields. If I create an array, I can change the contents as well:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const obj = { a: 1, b: 2 }\n// still the same object outside, but the contents have changed\nobj.b = 3\n\nconst arr = ['a', 'b']\n// In the same way, we can change the contents of this array\narr.push('c')\narr[1] = 'd'\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is called ",(0,a.jsx)(t.em,{children:"mutating"})," the object or array. It's the same object or array reference in memory, but now the contents inside the object have changed."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsxs)(t.strong,{children:["In order to update values immutably, your code must make ",(0,a.jsx)(t.em,{children:"copies"})," of existing objects/arrays, and then modify the copies"]}),"."]}),"\n",(0,a.jsx)(t.p,{children:"We can do this by hand using JavaScript's array / object spread operators, as well as array methods that return new copies of the array instead of mutating the original array:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const obj = {\n  a: {\n    // To safely update obj.a.c, we have to copy each piece\n    c: 3,\n  },\n  b: 2,\n}\n\nconst obj2 = {\n  // copy obj\n  ...obj,\n  // overwrite a\n  a: {\n    // copy obj.a\n    ...obj.a,\n    // overwrite c\n    c: 42,\n  },\n}\n\nconst arr = ['a', 'b']\n// Create a new copy of arr, with \"c\" appended to the end\nconst arr2 = arr.concat('c')\n\n// or, we can make a copy of the original array:\nconst arr3 = arr.slice()\n// and mutate the copy:\narr3.push('c')\n"})}),"\n",(0,a.jsxs)(t.admonition,{title:"Want to Know More?",type:"info",children:[(0,a.jsx)(t.p,{children:"For more info on how immutability works in JavaScript, see:"}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://daveceddia.com/javascript-references/",children:"A Visual Guide to References in JavaScript"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://daveceddia.com/react-redux-immutability-guide/",children:"Immutability in React and Redux: The Complete Guide"})}),"\n"]})]}),"\n",(0,a.jsx)(t.h3,{id:"reducers-and-immutable-updates",children:"Reducers and Immutable Updates"}),"\n",(0,a.jsxs)(t.p,{children:["One of the primary rules of Redux is that ",(0,a.jsxs)(t.strong,{children:["our reducers are ",(0,a.jsx)(t.em,{children:"never"})," allowed to mutate the original / current state values!"]})]}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// \u274c Illegal - by default, this will mutate the state!\nstate.value = 123\n"})})}),"\n",(0,a.jsx)(t.p,{children:"There are several reasons why you must not mutate state in Redux:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"It causes bugs, such as the UI not updating properly to show the latest values"}),"\n",(0,a.jsx)(t.li,{children:"It makes it harder to understand why and how the state has been updated"}),"\n",(0,a.jsx)(t.li,{children:"It makes it harder to write tests"}),"\n",(0,a.jsx)(t.li,{children:'It breaks the ability to use "time-travel debugging" correctly'}),"\n",(0,a.jsx)(t.li,{children:"It goes against the intended spirit and usage patterns for Redux"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"So if we can't change the originals, how do we return an updated state?"}),"\n",(0,a.jsxs)(t.admonition,{type:"tip",children:[(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Reducers can only make ",(0,a.jsx)(t.em,{children:"copies"})," of the original values, and then they can mutate the copies."]})}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// \u2705 This is safe, because we made a copy\nreturn {\n  ...state,\n  value: 123,\n}\n"})})]}),"\n",(0,a.jsx)(t.p,{children:"We already saw that we can write immutable updates by hand, by using JavaScript's array / object spread operators and other functions that return copies of the original values."}),"\n",(0,a.jsxs)(t.p,{children:["This becomes harder when the data is nested. ",(0,a.jsxs)(t.strong,{children:["A critical rule of immutable updates is that you must make a copy of ",(0,a.jsx)(t.em,{children:"every"})," level of nesting that needs to be updated."]})]}),"\n",(0,a.jsx)(t.p,{children:"A typical example of this might look like:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"function handwrittenReducer(state, action) {\n  return {\n    ...state,\n    first: {\n      ...state.first,\n      second: {\n        ...state.first.second,\n        [action.someId]: {\n          ...state.first.second[action.someId],\n          fourth: action.someValue,\n        },\n      },\n    },\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"However, if you're thinking that \"writing immutable updates by hand this way looks hard to remember and do correctly\"... yeah, you're right! :)"}),"\n",(0,a.jsxs)(t.p,{children:["Writing immutable update logic by hand ",(0,a.jsx)(t.em,{children:"is"})," hard, and ",(0,a.jsx)(t.strong,{children:"accidentally mutating state in reducers is the single most common mistake Redux users make"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"immutable-updates-with-immer",children:"Immutable Updates with Immer"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://immerjs.github.io/immer/",children:"Immer"})," is a library that simplifies the process of writing immutable update logic."]}),"\n",(0,a.jsxs)(t.p,{children:["Immer provides a function called ",(0,a.jsx)(t.code,{children:"produce"}),", which accepts two arguments: your original ",(0,a.jsx)(t.code,{children:"state"}),', and a callback function. The callback function is given a "draft" version of that state, and inside the callback, it is safe to write code that mutates the draft value. Immer tracks all attempts to mutate the draft value and then replays those mutations using their immutable equivalents to create a safe, immutably updated result:']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import produce from 'immer'\n\nconst baseState = [\n  {\n    todo: 'Learn typescript',\n    done: true,\n  },\n  {\n    todo: 'Try immer',\n    done: false,\n  },\n]\n\nconst nextState = produce(baseState, (draftState) => {\n  // \"mutate\" the draft array\n  draftState.push({ todo: 'Tweet about it' })\n  // \"mutate\" the nested state\n  draftState[1].done = true\n})\n\nconsole.log(baseState === nextState)\n// false - the array was copied\nconsole.log(baseState[0] === nextState[0])\n// true - the first item was unchanged, so same reference\nconsole.log(baseState[1] === nextState[1])\n// false - the second item was copied and updated\n"})}),"\n",(0,a.jsx)(t.h3,{id:"redux-toolkit-and-immer",children:"Redux Toolkit and Immer"}),"\n",(0,a.jsxs)(t.p,{children:["Redux Toolkit's ",(0,a.jsxs)(t.a,{href:"/api/createReducer",children:[(0,a.jsx)(t.code,{children:"createReducer"})," API"]}),' uses Immer internally automatically. So, it\'s already safe to "mutate" state inside of any case reducer function that is passed to ',(0,a.jsx)(t.code,{children:"createReducer"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const todosReducer = createReducer([], (builder) => {\n  builder.addCase('todos/todoAdded', (state, action) => {\n    // \"mutate\" the array by calling push()\n    state.push(action.payload)\n  })\n})\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In turn, ",(0,a.jsx)(t.code,{children:"createSlice"})," uses ",(0,a.jsx)(t.code,{children:"createReducer"}),' inside, so it\'s also safe to "mutate" state there as well:']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded(state, action) {\n      state.push(action.payload)\n    },\n  },\n})\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This even applies if the case reducer functions are defined outside of the ",(0,a.jsx)(t.code,{children:"createSlice/createReducer"}),' call. For example, you could have a reusable case reducer function that expects to "mutate" its state, and include it as needed:']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const addItemToArray = (state, action) => {\n  state.push(action.payload)\n}\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded: addItemToArray,\n  },\n})\n"})}),"\n",(0,a.jsxs)(t.p,{children:['This works because the "mutating" logic is wrapped in Immer\'s ',(0,a.jsx)(t.code,{children:"produce"})," method internally when it executes."]}),"\n",(0,a.jsx)(t.admonition,{type:"caution",children:(0,a.jsxs)(t.p,{children:["Remember, ",(0,a.jsxs)(t.strong,{children:['the "mutating" logic ',(0,a.jsx)(t.em,{children:"only"})," works correctly when wrapped inside of Immer!"]})," Otherwise, that code ",(0,a.jsx)(t.em,{children:"will"})," really mutate the data."]})}),"\n",(0,a.jsx)(t.h2,{id:"immer-usage-patterns",children:"Immer Usage Patterns"}),"\n",(0,a.jsx)(t.p,{children:"There are several useful patterns to know about and gotchas to watch out for when using Immer in Redux Toolkit."}),"\n",(0,a.jsx)(t.h3,{id:"mutating-and-returning-state",children:"Mutating and Returning State"}),"\n",(0,a.jsxs)(t.p,{children:["Immer works by tracking attempts to mutate an existing drafted state value, either by assigning to nested fields or by calling functions that mutate the value. That means that ",(0,a.jsxs)(t.strong,{children:["the ",(0,a.jsx)(t.code,{children:"state"})," must be a JS object or array in order for Immer to see the attempted changes"]}),". (You can still have a slice's state be a primitive like a string or a boolean, but since primitives can never be mutated anyway, all you can do is just return a new value.)"]}),"\n",(0,a.jsxs)(t.p,{children:["In any given case reducer, ",(0,a.jsxs)(t.strong,{children:["Immer expects that you will either ",(0,a.jsx)(t.em,{children:"mutate"})," the existing state, ",(0,a.jsx)(t.em,{children:"or"})," construct a new state value yourself and return it, but ",(0,a.jsx)(t.em,{children:"not"})," both in the same function!"]})," For example, both of these are valid reducers with Immer:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded(state, action) {\n      // \"Mutate\" the existing state, no return value needed\n      state.push(action.payload)\n    },\n    todoDeleted(state, action.payload) {\n      // Construct a new result array immutably and return it\n      return state.filter(todo => todo.id !== action.payload)\n    }\n  }\n})\n"})}),"\n",(0,a.jsxs)(t.p,{children:["However, it ",(0,a.jsx)(t.em,{children:"is"}),' possible to use immutable updates to do part of the work and then save the results via a "mutation". An example of this might be filtering a nested array:']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const todosSlice = createSlice({\n  name: 'todos',\n  initialState: {todos: [], status: 'idle'}\n  reducers: {\n    todoDeleted(state, action.payload) {\n      // Construct a new array immutably\n      const newTodos = state.todos.filter(todo => todo.id !== action.payload)\n      // \"Mutate\" the existing state to save the new array\n      state.todos = newTodos\n    }\n  }\n})\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that ",(0,a.jsx)(t.strong,{children:"mutating state in an arrow function with an implicit return breaks this rule and causes an error!"})," This is because statements and function calls may return a value, and Immer sees both the attempted mutation and ",(0,a.jsx)(t.em,{children:"and"})," the new returned value and doesn't know which to use as the result. Some potential solutions are using the ",(0,a.jsx)(t.code,{children:"void"})," keyword to skip having a return value, or using curly braces to give the arrow function a body and no return value:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    // \u274c ERROR: mutates state, but also returns new array size!\n    brokenReducer: (state, action) => state.push(action.payload),\n    // \u2705 SAFE: the `void` keyword prevents a return value\n    fixedReducer1: (state, action) => void state.push(action.payload),\n    // \u2705 SAFE: curly braces make this a function body and no return\n    fixedReducer2: (state, action) => {\n      state.push(action.payload)\n    },\n  },\n})\n"})}),"\n",(0,a.jsxs)(t.p,{children:["While writing nested immutable update logic is hard, there are times when it ",(0,a.jsx)(t.em,{children:"is"})," simpler to do an object spread operation to update multiple fields at once, vs assigning individual fields:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"function objectCaseReducer1(state, action) {\n  const { a, b, c, d } = action.payload\n  return {\n    ...state,\n    a,\n    b,\n    c,\n    d,\n  }\n}\n\nfunction objectCaseReducer2(state, action) {\n  const { a, b, c, d } = action.payload\n  // This works, but we keep having to repeat `state.x =`\n  state.a = a\n  state.b = b\n  state.c = c\n  state.d = d\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As an alternative, you can use ",(0,a.jsx)(t.code,{children:"Object.assign"})," to mutate multiple fields at once, since ",(0,a.jsx)(t.code,{children:"Object.assign"})," always mutates the first object that it's given:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"function objectCaseReducer3(state, action) {\n  const { a, b, c, d } = action.payload\n  Object.assign(state, { a, b, c, d })\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"resetting-and-replacing-state",children:"Resetting and Replacing State"}),"\n",(0,a.jsxs)(t.p,{children:["Sometimes you may want to replace the entire existing ",(0,a.jsx)(t.code,{children:"state"}),", either because you've loaded some new data, or you want to reset the state back to its initial value."]}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsxs)(t.p,{children:[(0,a.jsxs)(t.strong,{children:["A common mistake is to try assigning ",(0,a.jsx)(t.code,{children:"state = someValue"})," directly. This will not work!"]})," This only points the local ",(0,a.jsx)(t.code,{children:"state"})," variable to a different reference. That is neither mutating the existing ",(0,a.jsx)(t.code,{children:"state"})," object/array in memory, nor returning an entirely new value, so Immer does not make any actual changes."]})}),"\n",(0,a.jsx)(t.p,{children:"Instead, to replace the existing state, you should return the new value directly:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const initialState = []\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    brokenTodosLoadedReducer(state, action) {\n      // \u274c ERROR: does not actually mutate or return anything new!\n      state = action.payload\n    },\n    fixedTodosLoadedReducer(state, action) {\n      // \u2705 CORRECT: returns a new value to replace the old one\n      return action.payload\n    },\n    correctResetTodosReducer(state, action) {\n      // \u2705 CORRECT: returns a new value to replace the old one\n      return initialState\n    },\n  },\n})\n"})}),"\n",(0,a.jsx)(t.h3,{id:"debugging-and-inspecting-drafted-state",children:"Debugging and Inspecting Drafted State"}),"\n",(0,a.jsxs)(t.p,{children:["It's common to want to log in-progress state from a reducer to see what it looks like as it's being updated, like ",(0,a.jsx)(t.code,{children:"console.log(state)"}),". Unfortunately, browsers display logged Proxy instances in a format that is hard to read or understand:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Logged proxy draft",src:n(8654).A+"",width:"588",height:"86"})}),"\n",(0,a.jsxs)(t.p,{children:["To work around this, ",(0,a.jsxs)(t.a,{href:"https://immerjs.github.io/immer/current",children:["Immer includes a ",(0,a.jsx)(t.code,{children:"current"})," function that extracts a copy of the wrapped data"]}),", and RTK re-exports ",(0,a.jsx)(t.code,{children:"current"}),". You can use this in your reducers if you need to log or inspect the work-in-progress state:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import { current } from '@reduxjs/toolkit'\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: todosAdapter.getInitialState(),\n  reducers: {\n    todoToggled(state, action) {\n      // \u274c ERROR: logs the Proxy-wrapped data\n      console.log(state)\n      // \u2705 CORRECT: logs a plain JS copy of the current data\n      console.log(current(state))\n    },\n  },\n})\n"})}),"\n",(0,a.jsx)(t.p,{children:"The correct output would look like this instead:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Logged current value",src:n(109).A+"",width:"575",height:"112"})}),"\n",(0,a.jsxs)(t.p,{children:["Immer also provides ",(0,a.jsxs)(t.a,{href:"https://immerjs.github.io/immer/original",children:[(0,a.jsx)(t.code,{children:"original"})," and ",(0,a.jsx)(t.code,{children:"isDraft"})," functions"]}),", which retrieves the original data without any updates applied and check to see if a given value is a Proxy-wrapped draft. As of RTK 1.5.1, both of those are re-exported from RTK as well."]}),"\n",(0,a.jsx)(t.h3,{id:"updating-nested-data",children:"Updating Nested Data"}),"\n",(0,a.jsx)(t.p,{children:"Immer greatly simplifies updating nested data. Nested objects and arrays are also wrapped in Proxies and drafted, and it's safe to pull out a nested value into its own variable and then mutate it."}),"\n",(0,a.jsx)(t.p,{children:"However, this still only applies to objects and arrays. If we pull out a primitive value into its own variable and try to update it, Immer has nothing to wrap and cannot track any updates:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    brokenTodoToggled(state, action) {\n      const todo = state.find((todo) => todo.id === action.payload)\n      if (todo) {\n        // \u274c ERROR: Immer can't track updates to a primitive value!\n        let { completed } = todo\n        completed = !completed\n      }\n    },\n    fixedTodoToggled(state, action) {\n      const todo = state.find((todo) => todo.id === action.payload)\n      if (todo) {\n        // \u2705 CORRECT: This object is still wrapped in a Proxy, so we can \"mutate\" it\n        todo.completed = !todo.completed\n      }\n    },\n  },\n})\n"})}),"\n",(0,a.jsxs)(t.p,{children:["There ",(0,a.jsx)(t.em,{children:"is"})," a gotcha here. ",(0,a.jsx)(t.a,{href:"https://immerjs.github.io/immer/pitfalls#data-not-originating-from-the-state-will-never-be-drafted",children:"Immer will not wrap objects that are newly inserted into the state"}),". Most of the time this shouldn't matter, but there may be occasions when you want to insert a value and then make further updates to it."]}),"\n",(0,a.jsxs)(t.p,{children:["Related to this, RTK's ",(0,a.jsxs)(t.a,{href:"/api/createEntityAdapter#crud-functions",children:[(0,a.jsx)(t.code,{children:"createEntityAdapter"})," update functions"]}),' can either be used as standalone reducers, or "mutating" update functions. These functions determine whether to "mutate" or return a new value by checking to see if the state they\'re given is wrapped in a draft or not. If you are calling these functions yourself inside of a case reducer, be sure you know whether you\'re passing them a draft value or a plain value.']}),"\n",(0,a.jsxs)(t.p,{children:["Finally, it's worth noting that ",(0,a.jsx)(t.strong,{children:"Immer does not automatically create nested objects or arrays for you - you have to create them yourself"}),". As an example, say we have a lookup table containing nested arrays, and we want to insert an item into one of those arrays. If we unconditionally try to insert without checking for the existence of that array, the logic will crash when the array doesn't exist. Instead, you'd need to ensure the array exists first:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const itemsSlice = createSlice({\n  name: 'items',\n  initialState: { a: [], b: [] },\n  reducers: {\n    brokenNestedItemAdded(state, action) {\n      const { id, item } = action.payload\n      // \u274c ERROR: will crash if no array exists for `id`!\n      state[id].push(item)\n    },\n    fixedNestedItemAdded(state, action) {\n      const { id, item } = action.payload\n      // \u2705 CORRECT: ensures the nested array always exists first\n      if (!state[id]) {\n        state[id] = []\n      }\n\n      state[id].push(item)\n    },\n  },\n})\n"})}),"\n",(0,a.jsx)(t.h3,{id:"linting-state-mutations",children:"Linting State Mutations"}),"\n",(0,a.jsxs)(t.p,{children:["Many ESLint configs include the ",(0,a.jsx)(t.a,{href:"https://eslint.org/docs/rules/no-param-reassign",children:"https://eslint.org/docs/rules/no-param-reassign"})," rule, which may also warn about mutations to nested fields. That can cause the rule to warn about mutations to ",(0,a.jsx)(t.code,{children:"state"})," in Immer-powered reducers, which is not helpful."]}),"\n",(0,a.jsxs)(t.p,{children:["To resolve this, you can tell the ESLint rule to ignore mutations and assignment to a parameter named ",(0,a.jsx)(t.code,{children:"state"})," only in slice files:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// @filename .eslintrc.js\nmodule.exports = {\n  // add to your ESLint config definition\n  overrides: [\n    {\n      // feel free to replace with your preferred file pattern - eg. 'src/**/*Slice.ts'\n      files: ['src/**/*.slice.ts'],\n      // avoid state param assignment\n      rules: { 'no-param-reassign': ['error', { props: false }] },\n    },\n  ],\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"why-immer-is-built-in",children:"Why Immer is Built In"}),"\n",(0,a.jsxs)(t.p,{children:["We've received a number of requests over time to make Immer an optional part of RTK's ",(0,a.jsx)(t.code,{children:"createSlice"})," and ",(0,a.jsx)(t.code,{children:"createReducer"})," APIs, rather than strictly required."]}),"\n",(0,a.jsxs)(t.p,{children:["Our answer is always the same: ",(0,a.jsxs)(t.strong,{children:["Immer ",(0,a.jsx)(t.em,{children:"is required"})," in RTK, and that is not going to change"]}),"."]}),"\n",(0,a.jsx)(t.p,{children:"It's worth going over the reasons why we consider Immer to be a critical part of RTK and why we will not make it optional."}),"\n",(0,a.jsx)(t.h3,{id:"benefits-of-immer",children:"Benefits of Immer"}),"\n",(0,a.jsxs)(t.p,{children:["Immer has two primary benefits. First, ",(0,a.jsx)(t.strong,{children:"Immer drastically simplifies immutable update logic"}),". ",(0,a.jsx)(t.a,{href:"https://redux.js.org/usage/structuring-reducers/immutable-update-patterns#updating-nested-objects",children:"Proper immutable updates are extremely verbose"}),". Those verbose operations are hard to read overall, and also obfuscate what the actual intent of the update statement is. Immer eliminates all the nested spreads and array slices. Not only is the code shorter and easier to read, it's much more clear what actual update is supposed to happen."]}),"\n",(0,a.jsxs)(t.p,{children:["Second, ",(0,a.jsxs)(t.a,{href:"https://redux.js.org/usage/structuring-reducers/immutable-update-patterns",children:["writing immutable updates correctly is ",(0,a.jsx)(t.em,{children:"hard"})]}),", and it is really easy to make mistakes (like forgetting to copy a level of nesting in a set of object spreads, copying a top-level array and not the item to be updated inside the array, or forgetting that ",(0,a.jsx)(t.code,{children:"array.sort()"})," mutates the array). This is part of why ",(0,a.jsx)(t.a,{href:"https://redux.js.org/faq/react-redux#why-isnt-my-component-re-rendering-or-my-mapstatetoprops-running",children:"accidental mutations has always been the most common cause of Redux bugs"}),". ",(0,a.jsxs)(t.strong,{children:["Immer effectively ",(0,a.jsx)(t.em,{children:"eliminates"})," accidental mutations"]}),". Not only are there no more spread operations that can be mis-written, but Immer freezes state automatically as well. This causes errors to be thrown if you do accidentally mutate, even outside of a reducer. ",(0,a.jsxs)(t.strong,{children:["Eliminating the #1 cause of Redux bugs is a ",(0,a.jsx)(t.em,{children:"huge"})," improvement."]})]}),"\n",(0,a.jsxs)(t.p,{children:["Additionally, RTK Query uses Immer's patch capabilities to enable ",(0,a.jsx)(t.a,{href:"/rtk-query/usage/manual-cache-updates",children:"optimistic updates and manual cache updates"})," as well."]}),"\n",(0,a.jsx)(t.h3,{id:"tradeoffs-and-concerns",children:"Tradeoffs and Concerns"}),"\n",(0,a.jsx)(t.p,{children:"Like any tool, using Immer does have tradeoffs, and users have expressed a number of concerns about using it."}),"\n",(0,a.jsxs)(t.p,{children:["Immer does add to the overall app bundle size. It's about 8K min, 3.3K min+gz (ref: ",(0,a.jsx)(t.a,{href:"https://immerjs.github.io/immer/installation",children:"Immer docs: Installation"}),", ",(0,a.jsx)(t.a,{href:"https://bundle.js.org/?q=immer&treeshake=%5B%7Bdefault+as+produce+%7D%5D",children:"Bundle.js.org analysis"}),"). However, that library bundle size starts to pay for itself by shrinking the amount of reducer logic in your app. Additionally, the benefits of more readable code and eliminating mutation bugs are worth the size."]}),"\n",(0,a.jsxs)(t.p,{children:["Immer also adds a bit of overhead in runtime performance. However, ",(0,a.jsx)(t.a,{href:"https://immerjs.github.io/immer/performance/",children:'per the Immer "Performance" docs page, the overhead is not meaningful in practice'}),". Additionally, ",(0,a.jsx)(t.a,{href:"https://github.com/reduxjs/redux-toolkit/issues/242#issuecomment-583296008",children:"reducers are almost never a perf bottleneck in a Redux app anyway"}),". Instead, the cost of updating the UI is much more important."]}),"\n",(0,a.jsx)(t.p,{children:'So, while using Immer isn\'t "free", the bundle and perf costs are small enough to be worth it.'}),"\n",(0,a.jsxs)(t.p,{children:["The most realistic pain point with using Immer is that browser debuggers show Proxies in a confusing way, which makes it hard to inspect state variables while debugging. This is certainly an annoyance. However, this doesn't actually affect runtime behavior, and we've ",(0,a.jsxs)(t.a,{href:"#debugging-and-inspecting-drafted-state",children:["documented the use of ",(0,a.jsx)(t.code,{children:"current"})," to create a viewable plain JS version of the data"]})," above in this page. (Given the increasingly wide use of Proxies as part of libraries like Mobx and Vue 3, this is also not unique to Immer.)"]}),"\n",(0,a.jsxs)(t.p,{children:['Another issue is education and understanding. Redux has always required immutability in reducers, and so seeing "mutating" code can be confusing. It\'s certainly possible that new Redux users might see those "mutations" in example code, assume that it\'s normal for Redux usage, and later try to do the same thing outside of ',(0,a.jsx)(t.code,{children:"createSlice"}),". This would indeed cause real mutations and bugs, because it's outside of Immer's ability to wrap the updates."]}),"\n",(0,a.jsxs)(t.p,{children:["We've addressed this by ",(0,a.jsx)(t.a,{href:"https://redux.js.org/tutorials/essentials/part-1-overview-concepts#immutability",children:"repeatedly emphasizing the important of immutability throughout our docs"}),", including multiple highlighted sections emphasizing that ",(0,a.jsx)(t.a,{href:"https://redux.js.org/tutorials/essentials/part-2-app-structure#reducers-and-immutable-updates",children:'the "mutations" only work right thanks to Immer\'s "magic" inside'})," and adding this specific docs page you're reading now."]}),"\n",(0,a.jsx)(t.h3,{id:"architecture-and-intent",children:"Architecture and Intent"}),"\n",(0,a.jsx)(t.p,{children:"There's two more reasons why Immer is not optional."}),"\n",(0,a.jsxs)(t.p,{children:["One is RTK's architecture. ",(0,a.jsx)(t.code,{children:"createSlice"})," and ",(0,a.jsx)(t.code,{children:"createReducer"})," are implemented by directly importing Immer. There's no easy way to create a version of either of them that would have a hypothetical ",(0,a.jsx)(t.code,{children:"immer: false"})," option. You can't do optional imports, and we need Immer available immediately and synchronously during the initial load of the app."]}),"\n",(0,a.jsxs)(t.p,{children:["And finally: ",(0,a.jsx)(t.strong,{children:"Immer is built into RTK by default because we believe it is the best choice for our users!"})," We ",(0,a.jsx)(t.em,{children:"want"})," our users to be using Immer, and consider it to be a critical non-negotiable component of RTK. The great benefits like simpler reducer code and preventing accidental mutations far outweigh the relatively small concerns."]}),"\n",(0,a.jsx)(t.h2,{id:"further-information",children:"Further Information"}),"\n",(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"https://immerjs.github.io/immer/",children:"the Immer documentation"})," for more details on Immer's APIs, edge cases, and behavior."]}),"\n",(0,a.jsx)(t.p,{children:"For historical discussion on why Immer is required, see these issues:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://github.com/reduxjs/redux-toolkit/issues/5",children:"RTK #5: Why Immer inside a starter kit?"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://github.com/reduxjs/redux-toolkit/issues/183",children:"RTK #183: Consider adding an option to remove Immer"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsxs)(t.a,{href:"https://github.com/reduxjs/redux-toolkit/issues/242",children:["RTK #242: make ",(0,a.jsx)(t.code,{children:"immer"})," optional for ",(0,a.jsx)(t.code,{children:"createReducer"})]})}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},109:(e,t,n)=>{n.d(t,{A:()=>a});const a="data:image/png;base64,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"},8654:(e,t,n)=>{n.d(t,{A:()=>a});const a="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkwAAABWCAMAAAAKaDklAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMAUExURSEhITo6O0xNT01OT1ZWVlpcXlxdX15eXmJiY2lqamlqbW1ub3JycnR0dnl5enh5ew0iqig7sxwAzzxOu0Is105ewVZD2lxrxmRT3XBh4HWDzogTkZQunp1Cp6VTr6thtbFuu4Z75Ld7wYCAgICChYWFhYeJi4mJi4mKioqKi4uNkY6PkI+QkJCSk5SVlpOVmJSXm5manJianZueoZ6foZ6hpaSlqKSmqqSnq6mrrquusq+xtK+xta+ytrW4u7a5vYGO05mR6Jah2ryHx6Kb6bq+w7W+5by5777Bxr/H6LPL97TL98GRzMac0Mun1s+x2tO638LFycLGy8TIzcvQ1c7S19DU2tLW3NXZ3szM8sjQ68DU98fY+cze9c/e+tjE49zN59zO6N3f9dzh593h6N7j6d/k6tvh8tvm+Nrm++Tg8OPp9eTp8Obq8eXo9+Hr/Ojo9Ovx/ezx+PD1/fL2/vX4/v/w8Pv8//7+/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH3YsoAAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTnU1rJkAAANB0lEQVR4Xu2djVscVxWHicSSLo0lIRXDR0lgExOtxOKiFsRUDBttRCEBYogaLJAPWNJ0rTV/vud3zrmzd2bu7M7C4HNjz/s8yczcuVyYnXfPOTNzYQfahlERJpNRGSaTURkmk1EZJpNRGQGZWnM3tmRtaXZJVoT927f3eTE725AWZUO2czuWZmd1KO3Rmst+6enYPDewqqtVUR+otXSVSG/9H9HnYaY7vHz64AvmwdOX2sTkZdq69ZkasHXrli/Txu1fskyNDdLG39H4dA6GoLE15+1You4b6t9P0WPrRkrOFK3awMDAuU3dKsfe4AIvD4brx7yS4cmVy5fv6XqaxfN3dC3DwuCergl7g0FbF88Ti7qR5mhsZGTsSDfa7Z3RHV3rznEdQw4f6GaK5sjISFPXifFxXekOj3hhW7fSlDzMDn6Hl2KS4NuUk6nV2N9QmRpLDe/k7zdasENYmuuIurHUYpnYG5GHYbHELhoIPfzhsvBPmz3GHqzq26VApidX7rfvX3miWz4H9V+E9WvVMi9qrkG4Qy5uX3ioWz5HY+lT3Rx9oWu9OK6H7Ww3L6V8PBpb0bXuHAzTz3cnaFPZw+zgd3iqHjFPtRGEaiaVibyQs7/hsl1WpqXZDd5SmdC2dUtTJFqxt0G7qBEy7X+S7Muz+T2KSqv9haaFuq4EeX2VohL/l2Nx8WFYpr33Mj9AroHh834wHDr5Ox+l5SkZRgg++SHG0/KUjXXbw+RR+IcseZgefgfJcf/4z9dYPNBGUCwTXCiSSdNcWqatG7TV0KgGGmTX1g3aRcNApq1PfpsUUcTPPhB+zFurCEoUmVq1hYWBAVhSp7xHb4c67WjVBvfq3ObrQ12xeHje5azVAUl7wv0fftlu3wvluYMPtx9yQsG40qTwT+Gz+V4oVvJ558iUG2FFUhyS3QgFpSSMIFUhSL0YTWVBDz75RPoo8BWS4jDCCI3mYh1/C4y+QksvCzr4EFmmkx6mh9+BXUrQRlAsE4JPJi8lMjU6yQyITCTd7OxnnchEzbOzc582OPWxTBCrE932fiAy/ZW3EGVWSZ5W7ft1hKlWjRqQ9ug9IeuU01yRJMi75eDX8rIR6dNw7zolut9dva+bHot39MzlXuVcrAu/ytsfHtBpgsLpEWAKMXb0YpQCErxyJrhwsnOpWZSnwkcBU4hme4WSHY+muiYxb5y2Q8l0EcE3LFPJw/TIyvTq7dtv2KVSMnFOKpDJDz9AZQJezcRQzcTpTiIT7du/LdGMuMsu/UY2EIdwyHuDJA3JBHc09/0cLvG7yX9HbZ5LNvhly3H93vWrr7/8Ub5mosAksSVLPRMTwCpHyQwUDM+fDyYlFYVPOM62k0jrHt79YjQoU/goXCRij3g0lcgVZ7x7JSDTHSS4UGFX+jB9vA4i0at//42X2ggKZUKYIVLaqExLGZd8mVAi+VC5tHVDhtpgP/3CCYlOkhy9ebTA2zzHK5LC+P3QqnGdzREq9SrU3Ra/bFleX71MQYlzXQYKTGGZAm/QVF5NwAhhXnwEadQZL4wgwsCtSwgzQZcK6+8Vlkac8WIdrYzA0HGMGHBJjnAxdH1Y9jA9/A7s0Bdf9RGZmGDNtKGVEm2naiYg+W//thshuRkgV3P0n38diEQnSU5iENDgI97USSPKcQvwi3RzV2+KC9ZhMQrr74NhxJXghX2uDs01MIXnPRVGkJf8+hsBKVuee4SPIhXrOHn69TcCUqY8T+BEvn3hFIfpkeogEn39lSy1EeRlakgYkXVPJlRAiFS4NakdRCaJPHOtzh1JlYmCW6Ily8RFlO/D3Q/u6lqSwJwh8GiBLu5QL8k7qf6TWvoN5SITpa3jX1GKyFSu9ygoUaKjtYXUrU0JK7i4z9US+o1qe7W6lGfuPZweoXPecyNIJIIAKxwuINPncvZhGEomgdO5T4/6myylUETiQKadz3kXfzeUTEL6h0QJtn0hX9cRJQ8z0IERif71SpbaCEKR6X+IFkx0GPrSJplsb5BrqFXcet0bhGHpI0VX3T6uy725TAfKc5fZJdrhnR+tIiBT7oRy6KO0mryILhamRkjOe2AEjUR05TX2R0Qhvd/IZTRCiLsko69MnWG+Cxo6CheJcO3WRBTSm6Jc60NXd92Y/SExotxkOuFhhjowcmvgm7dvoVOvWwORks3rSWbsSenbV7nSwTWUHeFozEWeXvAVahmaSeTpxRkeZuor+rppGSfIeym0VO+NBLYyZL+H+xalRwhdVYVBCi9DwaVfgDM8zPRLXf5xSpy0aoFL14VyT2FDV8IFUG71XrVkq+wI46GrqiDefY2u0NVfWZfO7jDT3YnyD3oN44SYTEZlmExGZZhMRmWYTEZlmExGZcQr0+7kxMQaLd9MT0xMv5G2k7E+MTGxTks3onFGxCvTuhp0+PEuFjMz9N/61CHW82Dv7hR3DKFjkJiQqhfzQ0M3MRtkeWjo4nNpMsoQr0xrsIfY/RgCvZlGTFkrCFG8t9C0zq4uvqVYZpna7UcmUz9EK5PYQ4hAh1OIKRyeAnDkKdpJOAm7+JbCZDoR0cok9hDiCMcUCUBUAVHpszb9l4kJuIGaCiuJfSiNOOs9oz0yyIwTk8fKPEVfnqd8Nq/mzNOKyXRCopVJshtcYR9YoYnJ3fYa/YNoayQQlodTJAgij7NvXTvsTqEXh6SkVBKpsjKRSY/ff2QynZpoZcrU32wFZSlWBmFqhoIRS4UdXv0tHSbXST8yR2TqXn/DnOObyybTqYlWpoL6m6seWnID7eMlCyTeaAjDdqc+clHOSZXGZKqKaGVyZY5EKNYFAQjKILOxF7RPPKLM5upvF9H8elw9Q2TjZRqTqSpilUnsITL1N2c6SmDsBe3jNtRS3PH3u1wyAT+lOa9UqmzNpDI9vviY6ydtAiZTX8Qqk7sjJPlN3IFguHZbp6gFL3gfpbXpZ0hj7j73mqQ5NwCRqb+LZMLNyvnl+fbzi0PExefHN7F8/7F2M3oSq0yZ+vtUdK+/jcqIVaZ0/X06utffRmXEKtOMPt2l5KVF0AlJnhPTiMH626iMWGUy3kFMJqMyTCajMkwmozJMJqMyTCajMuKV6fRzwN3NAHdv3Dhj4pUpfQ+cp8D1fc+pr/voeIyyjBU3B9zok3hlyt0D9562dcdNEug84Q1PF8jBT+iAe9Br9EW0MukTXk+NkkYkz3NDY3THZDod0cqUmYNCqBE8+22N4pRO8XZzwHm6AKbxYj8mgXvZTfRK/4G/45t/uDk09MibNWAynZJoZXLZrfOoX4xwc8DdFO9kDvgM/ePg1UmHmTGyMpFJyxefm0yVEa1MudpZQhX/D13cFG+OVxS92COeqpvMtexef7M5PCHOZKqIaGUqqL/FGZJEp3hzWQTDZpDcuC3Ji93nsZhMlROtTK6KTuKM1N/wiDObKsORCqkvX3V31jh6ZTGZKidWmSSpEZn6m5TiOeCulIIw+BU6LpmSFiE7RrZmUpkw0Xue7zCZTKcjVplcFd1RQ4xwc8CTKhtzwP9EIiUXdZ0b3tkavkAmzPVenl9uP8KU76HOHHDtZ5QmVpn6uXfdES5NP2MYFRCrTGXngEMY99tNWaqcR26UIFaZys4BR3YLdqjub4UZZYlVJuMdxGQyKsNkMirDZDIqw2QyKsNkMiojXpnO7to+GdF+Y7xa4pUpc/8abumcNwHTBLqqEHy8q43ufmbyGNmogHhlKpiD4sAzFJ4+UEgyj8DHPeHTfclj5BTeR34bfRCtTMn5TgKMzEFxcMAKuyAE/xqTNrr5BAVP9UymkxGtTEVzUHhSAGmFgCUuUL6b3JW4xf+hA33N7tSfJ+VJi3TgpT56cdFOU2j6A7vH8QHf+IDUlfHmyAh5hQ98x4fL40NOS3/K6XeRaGVy57sTYMQql+ygFv5885tpaqYNlg/BC1Mw5U83T+7CNtfhzTR9hUY3VyrpN8l++rtGphUy6sVoM5Fp51Kzj89f/g4SrUy5+SOaktwUAYQZdOF4NaN/y5l8Y9mwgemX6Ow6sEe8QQuNdgX1t5OJohMkcjKtoBkbRphoZSqsv9c4ibEupALPiWOrqN6GeKwLwtnMtWnpqB0Q2FTIpDZ33ySDk0m9cTJJ/jOZColWJne+k+DRqb8Pp3AhJ39Qt5MFSYw1+hqWiSISdUCySzqwR+syBbNH/V0kE0cmo5hYZSqsv4mOSFoRMbvXnl0Tj6hkknm9KJ+SDkiBkzqfV4Oc+ybZmgn5DQuVqUmb41R5o2YyuhCrTO58a/BIkhX/lW/EGKgFv/g3eLFxOCW2oZgiRxDIuOZ2HcikqX9KAZapv3MyHY3J1ZzKhM2Vcb2as8u5YmKVKVd/V0mP+ts4IbHKlKu/q6RH/W2ckFhlomTFYaPXHPD+cb8J5R4kG5URq0zGO4jJZFSGyWRUhslkVMbA3w2jIga+NYyKMJmMivj22/8CcbWPrEwB1g4AAAAASUVORK5CYII="},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(6540);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);