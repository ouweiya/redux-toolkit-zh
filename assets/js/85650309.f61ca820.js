"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[1423],{425:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>c});var i=n(4848),s=n(8453);const d={id:"automated-refetching",title:"Automated Re-fetching",sidebar_label:"Automated Re-fetching",hide_title:!0,description:"RTK Query > Usage > Automated Refetching: cache invalidation management"},a="Automated Re-fetching",r={id:"rtk-query/usage/automated-refetching",title:"Automated Re-fetching",description:"RTK Query > Usage > Automated Refetching: cache invalidation management",source:"@site/docs/rtk-query/usage/automated-refetching.mdx",sourceDirName:"rtk-query/usage",slug:"/rtk-query/usage/automated-refetching",permalink:"/rtk-query/usage/automated-refetching",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rtk-query/usage/automated-refetching.mdx",tags:[],version:"current",frontMatter:{id:"automated-refetching",title:"Automated Re-fetching",sidebar_label:"Automated Re-fetching",hide_title:!0,description:"RTK Query > Usage > Automated Refetching: cache invalidation management"},sidebar:"docs",previous:{title:"Cache Behavior",permalink:"/rtk-query/usage/cache-behavior"},next:{title:"Manual Cache Updates",permalink:"/rtk-query/usage/manual-cache-updates"}},o={},c=[{value:"Definitions",id:"definitions",level:2},{value:"Tags",id:"tags",level:3},{value:"Providing tags",id:"providing-tags",level:3},{value:"Invalidating tags",id:"invalidating-tags",level:3},{value:"Cache tags",id:"cache-tags",level:2},{value:"Providing cache data",id:"providing-cache-data",level:3},{value:"Invalidating cache data",id:"invalidating-cache-data",level:3},{value:"Tag Invalidation Behavior",id:"tag-invalidation-behavior",level:2},{value:"General tag",id:"general-tag",level:3},{value:"Specific tag",id:"specific-tag",level:3},{value:"Recipes",id:"recipes",level:2},{value:"Advanced Invalidation with abstract tag IDs",id:"advanced-invalidation-with-abstract-tag-ids",level:3},{value:"Invalidating everything of a type",id:"invalidating-everything-of-a-type",level:4},{value:"Selectively invalidating lists",id:"selectively-invalidating-lists",level:4},{value:"Providing errors to the cache",id:"providing-errors-to-the-cache",level:3},{value:"Abstracting common provides/invalidates usage",id:"abstracting-common-providesinvalidates-usage",level:3}];function l(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"\xa0"}),"\n",(0,i.jsx)(t.h1,{id:"automated-re-fetching",children:"Automated Re-fetching"}),"\n",(0,i.jsxs)(t.p,{children:["As seen under ",(0,i.jsx)(t.a,{href:"/rtk-query/usage/cache-behavior#default-cache-behavior",children:"Default Cache Behavior"}),", when a subscription is added for a query endpoint, a request will be sent only if the cache data does not already exist. If it exists, the existing data will be served instead."]}),"\n",(0,i.jsxs)(t.p,{children:['RTK Query uses a "cache tag" system to automate re-fetching for query endpoints that have data affected by mutation endpoints. This enables designing your API such that firing a specific mutation will cause a certain query endpoint to consider its cached data ',(0,i.jsx)(t.em,{children:"invalid"}),", and re-fetch the data if there is an active subscription."]}),"\n",(0,i.jsxs)(t.p,{children:["Each endpoint + parameter combination contributes its own ",(0,i.jsx)(t.code,{children:"queryCacheKey"}),". The cache tag system enables the ability to inform RTK Query that a particular query cache has ",(0,i.jsx)(t.em,{children:"provided"})," specific tags. If a mutation is fired which is said to ",(0,i.jsx)(t.code,{children:"invalidate"})," tags that a query cache has ",(0,i.jsx)(t.em,{children:"provided"}),", the cached data will be considered ",(0,i.jsx)(t.em,{children:"invalidated"}),", and re-fetch if there is an active subscription to the cached data."]}),"\n",(0,i.jsxs)(t.p,{children:["For triggering re-fetching through other means, see ",(0,i.jsx)(t.a,{href:"/rtk-query/usage/cache-behavior#manipulating-cache-behavior",children:"Manipulating Cache Behavior"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"definitions",children:"Definitions"}),"\n",(0,i.jsx)(t.h3,{id:"tags",children:"Tags"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["see also: ",(0,i.jsx)(t.a,{href:"/rtk-query/api/createApi#tagtypes",children:"tagTypes API reference"})]})}),"\n",(0,i.jsxs)(t.p,{children:["For RTK Query, ",(0,i.jsx)(t.em,{children:"tags"})," are just a name that you can give to a specific collection of data to control caching and invalidation behavior for re-fetching purposes. It can be considered as a 'label' attached to cached data that is read after a mutation, to decide whether the data should be affected by the mutation."]}),"\n",(0,i.jsxs)(t.p,{children:["Tags are defined in the ",(0,i.jsx)(t.code,{children:"tagTypes"})," argument when defining an api. For example, in an application that has both ",(0,i.jsx)(t.code,{children:"Posts"})," and ",(0,i.jsx)(t.code,{children:"Users"}),", you might define ",(0,i.jsx)(t.code,{children:"tagTypes: ['Post', 'User']"})," when calling ",(0,i.jsx)(t.code,{children:"createApi"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["An individual ",(0,i.jsx)(t.code,{children:"tag"})," has a ",(0,i.jsx)(t.code,{children:"type"}),", represented as a ",(0,i.jsx)(t.code,{children:"string"})," name, and an optional ",(0,i.jsx)(t.code,{children:"id"}),", represented as a ",(0,i.jsx)(t.code,{children:"string"})," or ",(0,i.jsx)(t.code,{children:"number"}),". It can be represented as a plain string (such as ",(0,i.jsx)(t.code,{children:"'Post'"}),"), or an object in the shape ",(0,i.jsx)(t.code,{children:"{type: string, id?: string|number}"})," (such as ",(0,i.jsx)(t.code,{children:"[{type: 'Post', id: 1}]"}),")."]}),"\n",(0,i.jsx)(t.h3,{id:"providing-tags",children:"Providing tags"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["see also: ",(0,i.jsx)(t.a,{href:"/rtk-query/api/createApi#providestags",children:"providesTags API reference"})]})}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.em,{children:"query"})," can have its cached data ",(0,i.jsx)(t.em,{children:"provide"})," tags. Doing so determines which 'tag' is attached to the cached data returned by the query."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"providesTags"})," argument can either be an array of ",(0,i.jsx)(t.code,{children:"string"})," (such as ",(0,i.jsx)(t.code,{children:"['Post']"}),"), ",(0,i.jsx)(t.code,{children:"{type: string, id?: string|number}"})," (such as ",(0,i.jsx)(t.code,{children:"[{type: 'Post', id: 1}]"}),"), or a callback that returns such an array. That function will be passed the result as the first argument, the response error as the second argument, and the argument originally passed into the ",(0,i.jsx)(t.code,{children:"query"})," method as the third argument. Note that either the result or error arguments may be undefined based on whether the query was successful or not."]}),"\n",(0,i.jsx)(t.h3,{id:"invalidating-tags",children:"Invalidating tags"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["see also: ",(0,i.jsx)(t.a,{href:"/rtk-query/api/createApi#invalidatestags",children:"invalidatesTags API reference"})]})}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.em,{children:"mutation"})," can ",(0,i.jsx)(t.em,{children:"invalidate"})," specific cached data based on the tags. Doing so determines which cached data will be either refetched or removed from the cache."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"invalidatesTags"})," argument can either be an array of ",(0,i.jsx)(t.code,{children:"string"})," (such as ",(0,i.jsx)(t.code,{children:"['Post']"}),"), ",(0,i.jsx)(t.code,{children:"{type: string, id?: string|number}"})," (such as ",(0,i.jsx)(t.code,{children:"[{type: 'Post', id: 1}]"}),"), or a callback that returns such an array. That function will be passed the result as the first argument, the response error as the second argument, and the argument originally passed into the ",(0,i.jsx)(t.code,{children:"query"})," method as the third argument. Note that either the result or error arguments may be undefined based on whether the mutation was successful or not."]}),"\n",(0,i.jsx)(t.h2,{id:"cache-tags",children:"Cache tags"}),"\n",(0,i.jsxs)(t.p,{children:["RTK Query uses the concept of 'tags' to determine whether a mutation for one endpoint intends to ",(0,i.jsx)(t.em,{children:"invalidate"})," some data that was ",(0,i.jsx)(t.em,{children:"provided"})," by a query from another endpoint."]}),"\n",(0,i.jsx)(t.p,{children:"If cache data is being invalidated, it will either refetch the providing query (if components are still using that data) or remove the data from the cache."}),"\n",(0,i.jsxs)(t.p,{children:["When defining an API slice, ",(0,i.jsx)(t.code,{children:"createApi"})," accepts an array of tag type names for the ",(0,i.jsx)(t.code,{children:"tagTypes"})," property, which is a list of possible tag name options that the queries for the API slice could provide."]}),"\n",(0,i.jsx)(t.p,{children:"The example below declares that endpoints can possibly provide 'Posts' and/or 'Users' to the cache:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="Example of declaring cache tags"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  // highlight-start\n  tagTypes: ['Post', 'User'],\n  // highlight-end\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({\n      query: (body) => ({\n        url: 'post',\n        method: 'POST',\n        body,\n      }),\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({\n      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["By declaring these tags as what can possibly be provided to the cache, it enables control for individual mutation endpoints to claim whether they affect specific portions of the cache or not, in conjunction with ",(0,i.jsx)(t.code,{children:"providesTags"})," and ",(0,i.jsx)(t.code,{children:"invalidatesTags"})," on individual endpoints."]}),"\n",(0,i.jsx)(t.h3,{id:"providing-cache-data",children:"Providing cache data"}),"\n",(0,i.jsxs)(t.p,{children:["Each individual ",(0,i.jsx)(t.code,{children:"query"})," endpoint can have its cached data ",(0,i.jsx)(t.em,{children:"provide"})," particular tags. Doing so enables a relationship between cached data from one or more query endpoints and the behaviour of one or more mutation endpoints."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"providesTags"})," property on a ",(0,i.jsx)(t.code,{children:"query"})," endpoint is used for this purpose."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["Provided tags have no inherent relationship across separate ",(0,i.jsx)(t.code,{children:"query"})," endpoints. Provided tags are used to determine whether cached data returned by an endpoint should be ",(0,i.jsx)(t.code,{children:"invalidated"})," and either be refetched or removed from the cache. If two separate endpoints provide the same tags, they will still contribute their own distinct cached data, which could later both be invalidated by a single tag declared from a mutation."]})}),"\n",(0,i.jsxs)(t.p,{children:["The example below declares that the ",(0,i.jsx)(t.code,{children:"getPosts"})," ",(0,i.jsx)(t.code,{children:"query"})," endpoint ",(0,i.jsx)(t.code,{children:"provides"})," the ",(0,i.jsx)(t.code,{children:"'Post'"})," tag to the cache, using the ",(0,i.jsx)(t.code,{children:"providesTags"})," property for a ",(0,i.jsx)(t.code,{children:"query"})," endpoint."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="Example of providing tags to the cache"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      // highlight-start\n      providesTags: ['Post'],\n      // highlight-end\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n      // highlight-start\n      providesTags: ['User'],\n      // highlight-end\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({\n      query: (body) => ({\n        url: 'posts',\n        method: 'POST',\n        body,\n      }),\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({\n      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For more granular control over the provided data, provided ",(0,i.jsx)(t.code,{children:"tags"})," can have an associated ",(0,i.jsx)(t.code,{children:"id"}),". This enables a distinction between 'any of a particular tag type', and 'a specific instance of a particular tag type'."]}),"\n",(0,i.jsx)(t.p,{children:"The example below declares that the provided posts are associated with particular IDs as determined by the result returned by the endpoint:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="Example of providing tags with IDs to the cache"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      // highlight-start\n      providesTags: (result, error, arg) =>\n        result\n          ? [...result.map(({ id }) => ({ type: 'Post' as const, id })), 'Post']\n          : ['Post'],\n      // highlight-end\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n      providesTags: ['User'],\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({\n      query: (body) => ({\n        url: 'post',\n        method: 'POST',\n        body,\n      }),\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({\n      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note that for the example above, the ",(0,i.jsx)(t.code,{children:"id"})," is used where possible on a successful result. In the case of an error, no result is supplied, and we still consider that it has provided the general ",(0,i.jsx)(t.code,{children:"'Post'"})," tag type rather than any specific instance of that tag."]}),"\n",(0,i.jsx)(t.admonition,{title:"Advanced List Invalidation",type:"tip",children:(0,i.jsxs)(t.p,{children:["In order to provide stronger control over invalidating the appropriate data, you can use an arbitrary ID such as ",(0,i.jsx)(t.code,{children:"'LIST'"})," for a given tag. See ",(0,i.jsx)(t.a,{href:"#advanced-invalidation-with-abstract-tag-ids",children:"Advanced Invalidation with abstract tag IDs"})," for additional details."]})}),"\n",(0,i.jsx)(t.h3,{id:"invalidating-cache-data",children:"Invalidating cache data"}),"\n",(0,i.jsxs)(t.p,{children:["Each individual mutation endpoint can ",(0,i.jsx)(t.code,{children:"invalidate"})," particular tags for existing cached data. Doing so enables a relationship between cached data from one or more query endpoints and the behaviour of one or more mutation endpoints."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"invalidatesTags"})," property on a mutation endpoint is used for this purpose."]}),"\n",(0,i.jsxs)(t.p,{children:["The example below declares that the ",(0,i.jsx)(t.code,{children:"addPost"})," and ",(0,i.jsx)(t.code,{children:"editPost"})," mutation endpoints ",(0,i.jsx)(t.code,{children:"invalidate"})," any cached data with the ",(0,i.jsx)(t.code,{children:"'Post'"})," tag, using the ",(0,i.jsx)(t.code,{children:"invalidatesTags"})," property for a mutation endpoint:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="Example of invalidating tags in the cache"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      providesTags: (result, error, arg) =>\n        result\n          ? [...result.map(({ id }) => ({ type: 'Post' as const, id })), 'Post']\n          : ['Post'],\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n      providesTags: ['User'],\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({\n      query: (body) => ({\n        url: 'post',\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      invalidatesTags: ['Post'],\n      // highlight-end\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({\n      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      invalidatesTags: ['Post'],\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For the example above, this tells RTK Query that after the ",(0,i.jsx)(t.code,{children:"addPost"})," and/or ",(0,i.jsx)(t.code,{children:"editPost"})," mutations are called and completed, any cache data supplied with the ",(0,i.jsx)(t.code,{children:"'Post'"})," tag is no longer valid. If a component is currently subscribed to the cached data for a ",(0,i.jsx)(t.code,{children:"'Post'"})," tag after the above mutations are called and complete, it will automatically re-fetch in order to retrieve up to date data from the server."]}),"\n",(0,i.jsx)(t.p,{children:"An example scenario would be like so:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["A component is rendered which is using the ",(0,i.jsx)(t.code,{children:"useGetPostsQuery()"})," hook to subscribe to that endpoint's cached data"]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"/posts"})," request is fired off, and server responds with posts with IDs 1, 2 & 3"]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"getPosts"})," endpoint stores the received data in the cache, and internally registers that the following tags have been provided:","\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"[\n  { type: 'Post', id: 1 },\n  { type: 'Post', id: 2 },\n  { type: 'Post', id: 3 },\n]\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"editPost"})," mutation is fired off to alter a particular post"]}),"\n",(0,i.jsxs)(t.li,{children:["Upon completion, RTK Query internally registers that the ",(0,i.jsx)(t.code,{children:"'Post'"})," tag is now invalidated, and removes the previously provided ",(0,i.jsx)(t.code,{children:"'Post'"})," tags from the cache"]}),"\n",(0,i.jsxs)(t.li,{children:["Since the ",(0,i.jsx)(t.code,{children:"getPosts"})," endpoint has provided tags of type ",(0,i.jsx)(t.code,{children:"'Post'"})," which now has invalid cache data, and the component is still subscribed to the data, the ",(0,i.jsx)(t.code,{children:"/posts"})," request is automatically fired off again, fetching new data and registering new tags for the updated cached data"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["For more granular control over the invalidated data, invalidated ",(0,i.jsx)(t.code,{children:"tags"})," can have an associated ",(0,i.jsx)(t.code,{children:"id"})," in the same manner as ",(0,i.jsx)(t.code,{children:"providesTags"}),". This enables a distinction between 'any of a particular tag type' and 'a specific instance of a particular tag type'."]}),"\n",(0,i.jsxs)(t.p,{children:["The example below declares that the ",(0,i.jsx)(t.code,{children:"editPost"})," mutation invalidates a specific instance of a ",(0,i.jsx)(t.code,{children:"Post"})," tag, using the ID passed in when calling the mutation function:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="Example of invalidating tags with IDs to the cache"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      providesTags: (result, error, arg) =>\n        result\n          ? [...result.map(({ id }) => ({ type: 'Post' as const, id })), 'Post']\n          : ['Post'],\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => '/users',\n      providesTags: ['User'],\n    }),\n    addPost: build.mutation<Post, Omit<Post, 'id'>>({\n      query: (body) => ({\n        url: 'post',\n        method: 'POST',\n        body,\n      }),\n      invalidatesTags: ['Post'],\n    }),\n    editPost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({\n      query: (body) => ({\n        url: `post/${body.id}`,\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      invalidatesTags: (result, error, arg) => [{ type: 'Post', id: arg.id }],\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For the example above, rather than invalidating any tag with the type ",(0,i.jsx)(t.code,{children:"'Post'"}),", calling the ",(0,i.jsx)(t.code,{children:"editPost"})," mutation function will now only invalidate a tag for the provided ",(0,i.jsx)(t.code,{children:"id"}),". I.e. if cached data from an endpoint does not provide a ",(0,i.jsx)(t.code,{children:"'Post'"})," for that same ",(0,i.jsx)(t.code,{children:"id"}),", it will remain considered as 'valid', and will not be triggered to automatically re-fetch."]}),"\n",(0,i.jsx)(t.admonition,{title:"Using abstract tag IDs",type:"tip",children:(0,i.jsxs)(t.p,{children:["In order to provide stronger control over invalidating the appropriate data, you can use an arbitrary ID such as ",(0,i.jsx)(t.code,{children:"'LIST'"})," for a given tag. See ",(0,i.jsx)(t.a,{href:"#advanced-invalidation-with-abstract-tag-ids",children:"Advanced Invalidation with abstract tag IDs"})," for additional details."]})}),"\n",(0,i.jsx)(t.h2,{id:"tag-invalidation-behavior",children:"Tag Invalidation Behavior"}),"\n",(0,i.jsx)(t.p,{children:"The matrix below shows examples of which invalidated tags will affect and invalidate which provided tags:"}),"\n",(0,i.jsxs)("table",{className:"checkbox-table",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{className:"diagonal-cell",children:(0,i.jsxs)("div",{className:"diagonal-cell--content",children:[(0,i.jsx)("div",{className:"diagonal-cell--topRight",children:"Provided"}),(0,i.jsx)("div",{className:"diagonal-cell--bottomLeft",children:"Invalidated"})]})}),(0,i.jsxs)("th",{children:[(0,i.jsx)("div",{children:"General tag A"}),(0,i.jsxs)("div",{style:{fontWeight:"normal",fontSize:"0.9rem"},children:["['Post']",(0,i.jsx)("br",{}),"/",(0,i.jsx)("br",{}),"[{ type: 'Post' }]"]})]}),(0,i.jsxs)("th",{children:[(0,i.jsx)("div",{children:"General tag B"}),(0,i.jsxs)("div",{style:{fontWeight:"normal",fontSize:"0.9rem"},children:["['User']",(0,i.jsx)("br",{}),"/",(0,i.jsx)("br",{}),"[{ type: 'User' }]"]})]}),(0,i.jsxs)("th",{children:[(0,i.jsx)("div",{children:"Specific tag A1"}),(0,i.jsxs)("div",{style:{fontWeight:"normal",fontSize:"0.9rem"},children:["[{ type: 'Post',",(0,i.jsx)("br",{})," id: 1 }]"]})]}),(0,i.jsxs)("th",{children:[(0,i.jsx)("div",{children:"Specific tag A2"}),(0,i.jsx)("div",{style:{fontWeight:"normal",fontSize:"0.9rem"},children:"[{ type: 'Post', id: 'LIST' }]"})]}),(0,i.jsxs)("th",{children:[(0,i.jsx)("div",{children:"Specific tag B1"}),(0,i.jsxs)("div",{style:{fontWeight:"normal",fontSize:"0.9rem"},children:["[{ type: 'User',",(0,i.jsx)("br",{})," id: 1 }]"]})]}),(0,i.jsxs)("th",{children:[(0,i.jsx)("div",{children:"Specific tag B2"}),(0,i.jsxs)("div",{style:{fontWeight:"normal",fontSize:"0.9rem"},children:["[{ type: 'User',",(0,i.jsx)("br",{})," id: 2 }]"]})]})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("div",{style:{fontWeight:"bold"},children:"General tag A"}),(0,i.jsx)("div",{style:{fontSize:"0.9rem"},children:"['Post'] / [{ type: 'Post' }]"})]}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("div",{style:{fontWeight:"bold"},children:"General tag B"}),(0,i.jsxs)("div",{style:{fontSize:"0.9rem"},children:["['User'] /",(0,i.jsx)("br",{}),"[{ type: 'User' }]"]})]}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{children:"\u2714\ufe0f"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("div",{style:{fontWeight:"bold"},children:"Specific tag A1"}),(0,i.jsx)("div",{style:{fontSize:"0.9rem"},children:"[{ type: 'Post', id: 1 }]"})]}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("div",{style:{fontWeight:"bold"},children:"Specific tag A2"}),(0,i.jsx)("div",{style:{fontSize:"0.9rem"},children:"[{ type: 'Post', id: 'LIST' }]"})]}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("div",{style:{fontWeight:"bold"},children:"Specific tag B1"}),(0,i.jsx)("div",{style:{fontSize:"0.9rem"},children:"[{ type: 'User', id: 1 }]"})]}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{children:"\u2714\ufe0f"}),(0,i.jsx)("td",{})]}),(0,i.jsxs)("tr",{children:[(0,i.jsxs)("td",{children:[(0,i.jsx)("div",{style:{fontWeight:"bold"},children:"Specific tag B2"}),(0,i.jsx)("div",{style:{fontSize:"0.9rem"},children:"[{ type: 'User', id: 2 }]"})]}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{}),(0,i.jsx)("td",{children:"\u2714\ufe0f"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"The invalidation behavior is summarized based on tag specificity in the sections below."}),"\n",(0,i.jsx)(t.h3,{id:"general-tag",children:"General tag"}),"\n",(0,i.jsxs)(t.p,{children:["e.g. ",(0,i.jsx)(t.code,{children:"['Post'] / [{ type: 'Post' }]"})]}),"\n",(0,i.jsxs)(t.p,{children:["Will ",(0,i.jsx)(t.code,{children:"invalidate"})," any ",(0,i.jsx)(t.code,{children:"provided"})," tag with the matching type, including general and specific tags."]}),"\n",(0,i.jsxs)(t.p,{children:["Example:",(0,i.jsx)(t.br,{}),"\n","If a general tag of ",(0,i.jsx)(t.code,{children:"Post"})," was invalidated, endpoints whose data ",(0,i.jsx)(t.code,{children:"provided"})," the following tags would all have their data invalidated:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"['Post']"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post' }, { type: 'Post', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }, { type: 'User' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 'LIST' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }, { type: 'Post', id: 'LIST' }]"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Endpoints whose data ",(0,i.jsx)(t.code,{children:"provided"})," the following tags would ",(0,i.jsx)(t.em,{children:"not"})," have their data invalidated:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"['User']"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 'LIST' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 1 }, { type: 'User', id: 'LIST' }]"})}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"specific-tag",children:"Specific tag"}),"\n",(0,i.jsxs)(t.p,{children:["e.g. ",(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }]"})]}),"\n",(0,i.jsxs)(t.p,{children:["Will ",(0,i.jsx)(t.code,{children:"invalidate"})," any ",(0,i.jsx)(t.code,{children:"provided"})," tag with both the matching type, ",(0,i.jsx)(t.em,{children:"and"})," matching id. Will not cause a ",(0,i.jsx)(t.code,{children:"general"})," tag to be invalidated directly, but ",(0,i.jsx)(t.em,{children:"might"})," invalidate data for an endpoint that provides a ",(0,i.jsx)(t.code,{children:"general"})," tag ",(0,i.jsx)(t.em,{children:"if"})," it also provides a matching ",(0,i.jsx)(t.code,{children:"specific"})," tag."]}),"\n",(0,i.jsxs)(t.p,{children:["Example 1:\nIf a specific tag of ",(0,i.jsx)(t.code,{children:"{ type: 'Post', id: 1 }"})," was invalidated, endpoints whose data ",(0,i.jsx)(t.code,{children:"provided"})," the following tags would all have their data invalidated:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post' }, { type: 'Post', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }, { type: 'User' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }, { type: 'Post', id: 'LIST' }]"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Endpoints whose data ",(0,i.jsx)(t.code,{children:"provided"})," the following tags would ",(0,i.jsx)(t.em,{children:"not"})," have their data invalidated:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"['Post']"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 'LIST' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"['User']"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 'LIST' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 1 }, { type: 'User', id: 'LIST' }]"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Example 2:\nIf a specific tag of ",(0,i.jsx)(t.code,{children:"{ type: 'Post', id: 'LIST' }"})," was invalidated, endpoints whose data ",(0,i.jsx)(t.code,{children:"provided"})," the following tags would all have their data invalidated:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 'LIST' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }, { type: 'Post', id: 'LIST' }]"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Endpoints whose data ",(0,i.jsx)(t.code,{children:"provided"})," the following tags would ",(0,i.jsx)(t.em,{children:"not"})," have their data invalidated:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"['Post']"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post' }, { type: 'Post', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Post', id: 1 }, { type: 'User' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"['User']"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 1 }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 'LIST' }]"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'User', id: 1 }, { type: 'User', id: 'LIST' }]"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"recipes",children:"Recipes"}),"\n",(0,i.jsx)(t.h3,{id:"advanced-invalidation-with-abstract-tag-ids",children:"Advanced Invalidation with abstract tag IDs"}),"\n",(0,i.jsxs)(t.p,{children:["While using an 'entity ID' for a tag ",(0,i.jsx)(t.code,{children:"id"})," is a common use case, the ",(0,i.jsx)(t.code,{children:"id"})," property is not intended to be limited to database IDs alone. The ",(0,i.jsx)(t.code,{children:"id"})," is simply a way to label a subset of a particular collection of data for a particular ",(0,i.jsx)(t.code,{children:"tag type"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["A powerful use-case is to use an ID like ",(0,i.jsx)(t.code,{children:"'LIST'"})," as a label for data provided by a bulk query, ",(0,i.jsx)(t.em,{children:"as well as"})," using entity IDs for the individual items. Doing so allows future ",(0,i.jsx)(t.code,{children:"mutations"})," to declare whether they invalidate the data only if it contains a particular item (e.g. ",(0,i.jsx)(t.code,{children:"{ type: 'Post', id: 5 }"}),"), or invalidate the data if it is a ",(0,i.jsx)(t.code,{children:"'LIST'"})," (e.g. ",(0,i.jsx)(t.code,{children:"{ type: 'Post', id: 'LIST' }"}),")."]}),"\n",(0,i.jsx)(t.admonition,{title:"'LIST' Tag and IDs",type:"info",children:(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"LIST"})," is an arbitrary string - technically speaking, you could use anything you want here, such as ",(0,i.jsx)(t.code,{children:"ALL"})," or ",(0,i.jsx)(t.code,{children:"*"}),". The important thing when choosing a custom id is to make sure there is no possibility of it colliding with an id that is returned by a query result. If you have unknown ids in your query results and don't want to risk it, you can go with point 3 below."]}),"\n",(0,i.jsxs)(t.li,{children:["You can add ",(0,i.jsx)(t.em,{children:"many"})," tag types for even more control","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"[{ type: 'Posts', id: 'LIST' }, { type: 'Posts', id: 'SVELTE_POSTS' }, { type: 'Posts', id: 'REACT_POSTS' }]"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["If the concept of using an ",(0,i.jsx)(t.code,{children:"id"})," like 'LIST' seems strange to you, you can always add another ",(0,i.jsx)(t.code,{children:"tagType"})," and invalidate its root, but we recommend using the ",(0,i.jsx)(t.code,{children:"id"})," approach as shown."]}),"\n"]})}),"\n",(0,i.jsxs)(t.p,{children:["We can compare the scenarios below to see how using a ",(0,i.jsx)(t.code,{children:"'LIST'"})," id can be leveraged to optimize behaviour."]}),"\n",(0,i.jsx)(t.h4,{id:"invalidating-everything-of-a-type",children:"Invalidating everything of a type"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="API Definition"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post, User } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result ? result.map(({ id }) => ({ type: 'Posts', id })) : ['Posts'],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query: (body) => ({\n        url: `post`,\n        method: 'POST',\n        body,\n      }),\n      invalidatesTags: ['Posts'],\n    }),\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: (result, error, id) => [{ type: 'Posts', id }],\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery, useGetPostQuery, useAddPostMutation } = api\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="App.tsx"',children:"function App() {\n  const { data: posts } = useGetPostsQuery()\n  const [addPost] = useAddPostMutation()\n\n  return (\n    <div>\n      <AddPost onAdd={addPost} />\n      <PostsList />\n      {/* Assume each PostDetail is subscribed via `const {data} = useGetPostQuery(id)` */}\n      <PostDetail id={1} />\n      <PostDetail id={2} />\n      <PostDetail id={3} />\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"What to expect"})}),"\n",(0,i.jsxs)(t.p,{children:["When ",(0,i.jsx)(t.code,{children:"addPost"})," is triggered, it would cause each ",(0,i.jsx)(t.code,{children:"PostDetail"})," component to go back into a ",(0,i.jsx)(t.code,{children:"isFetching"})," state because ",(0,i.jsx)(t.code,{children:"addPost"})," invalidates the root tag, which causes ",(0,i.jsx)(t.em,{children:"every query"})," that provides 'Posts' to be re-run. In most cases, this may not be what you want to do. Imagine if you had 100 posts on the screen that all subscribed to a ",(0,i.jsx)(t.code,{children:"getPost"})," query \u2013 in this case, you'd create 100 requests and send a ton of unnecessary traffic to your server, which we're trying to avoid in the first place! Even though the user would still see the last good cached result and potentially not notice anything other than their browser hiccuping, you still want to avoid this."]}),"\n",(0,i.jsx)(t.h4,{id:"selectively-invalidating-lists",children:"Selectively invalidating lists"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="API Definition"',children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Post, User } from './types'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query(body) {\n        return {\n          url: `post`,\n          method: 'POST',\n          body,\n        }\n      },\n      invalidatesTags: [{ type: 'Posts', id: 'LIST' }],\n    }),\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: (result, error, id) => [{ type: 'Posts', id }],\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery, useAddPostMutation, useGetPostQuery } = api\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="App.tsx"',children:"function App() {\n  const { data: posts } = useGetPostsQuery()\n  const [addPost] = useAddPostMutation()\n\n  return (\n    <div>\n      <AddPost onAdd={addPost} />\n      <PostsList />\n      {/* Assume each PostDetail is subscribed via `const {data} = useGetPostQuery(id)` */}\n      <PostDetail id={1} />\n      <PostDetail id={2} />\n      <PostDetail id={3} />\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"What to expect"})}),"\n",(0,i.jsxs)(t.p,{children:["When ",(0,i.jsx)(t.code,{children:"addPost"})," is fired, it will only cause the ",(0,i.jsx)(t.code,{children:"PostsList"})," to go into an ",(0,i.jsx)(t.code,{children:"isFetching"})," state because ",(0,i.jsx)(t.code,{children:"addPost"})," only invalidates the ",(0,i.jsx)(t.code,{children:"'LIST'"})," id, which causes ",(0,i.jsx)(t.code,{children:"getPosts"})," to rerun (because it provides that specific id). So in your network tab, you would only see 1 new request fire for ",(0,i.jsx)(t.code,{children:"GET /posts"}),". As the singular ",(0,i.jsx)(t.code,{children:"getPost"})," queries have not been invalidated, they will not re-run as a result of ",(0,i.jsx)(t.code,{children:"addPost"}),"."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["If you intend for the ",(0,i.jsx)(t.code,{children:"addPost"})," mutation to refresh all posts including individual ",(0,i.jsx)(t.code,{children:"PostDetail"})," components while still only making 1 new ",(0,i.jsx)(t.code,{children:"GET /posts"})," request, this can be done by selecting a part of the data using ",(0,i.jsx)(t.a,{href:"/rtk-query/usage/queries#selecting-data-from-a-query-result",children:(0,i.jsx)(t.code,{children:"selectFromResult"})}),"."]})}),"\n",(0,i.jsx)(t.h3,{id:"providing-errors-to-the-cache",children:"Providing errors to the cache"}),"\n",(0,i.jsxs)(t.p,{children:["The information provided to the cache is not limited to successful data fetches. The concept can be used to inform RTK Query that when a particular failure has been encountered, to ",(0,i.jsx)(t.code,{children:"provide"})," a specific ",(0,i.jsx)(t.code,{children:"tag"})," for that failed cache data. A separate endpoint can then ",(0,i.jsx)(t.code,{children:"invalidate"})," the data for that ",(0,i.jsx)(t.code,{children:"tag"}),", telling RTK Query to re-attempt the previously failed endpoints if a component is still subscribed to the failed data."]}),"\n",(0,i.jsx)(t.p,{children:"The example below demonstrates an example with the following behaviour:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Provides an ",(0,i.jsx)(t.code,{children:"UNAUTHORIZED"})," cache tag if a query fails with an error code of ",(0,i.jsx)(t.code,{children:"401 UNAUTHORIZED"})]}),"\n",(0,i.jsxs)(t.li,{children:["Provides an ",(0,i.jsx)(t.code,{children:"UNKNOWN_ERROR"})," cache tag if a query fails with a different error"]}),"\n",(0,i.jsxs)(t.li,{children:["Enables a 'login' mutation, which when ",(0,i.jsx)(t.em,{children:"successful"}),", will ",(0,i.jsx)(t.code,{children:"invalidate"})," the data with the ",(0,i.jsx)(t.code,{children:"UNAUTHORIZED"})," tag.",(0,i.jsx)(t.br,{}),"\n","This will trigger the ",(0,i.jsx)(t.code,{children:"postById"})," endpoint to re-fire if:","\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["The last call for ",(0,i.jsx)(t.code,{children:"postById"})," had encountered an unauthorized error, and"]}),"\n",(0,i.jsx)(t.li,{children:"A component is still subscribed to the cached data"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Enables a 'refetchErroredQueries' mutation which when ",(0,i.jsx)(t.em,{children:"called"}),", will ",(0,i.jsx)(t.code,{children:"invalidate"})," the data with the ",(0,i.jsx)(t.code,{children:"UNKNOWN_ERROR"})," tag.",(0,i.jsx)(t.br,{}),"\n","This will trigger the ",(0,i.jsx)(t.code,{children:"postById"})," endpoint to re-fire if:","\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["The last call for ",(0,i.jsx)(t.code,{children:"postById"})," had encountered an unknown error, and"]}),"\n",(0,i.jsx)(t.li,{children:"A component is still subscribed to the cached data"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\nexport interface LoginResponse {}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { Post, LoginResponse } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),\n  tagTypes: ['Post', 'UNAUTHORIZED', 'UNKNOWN_ERROR'],\n  endpoints: (build) => ({\n    postById: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: (result, error, id) =>\n        result\n          ? [{ type: 'Post', id }]\n          : error?.status === 401\n            ? ['UNAUTHORIZED']\n            : ['UNKNOWN_ERROR'],\n    }),\n    login: build.mutation<LoginResponse, void>({\n      query: () => '/login',\n      // on successful login, will refetch all currently\n      // 'UNAUTHORIZED' queries\n      invalidatesTags: (result) => (result ? ['UNAUTHORIZED'] : []),\n    }),\n    refetchErroredQueries: build.mutation<null, void>({\n      queryFn: () => ({ data: null }),\n      invalidatesTags: ['UNKNOWN_ERROR'],\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsx)(t.h3,{id:"abstracting-common-providesinvalidates-usage",children:"Abstracting common provides/invalidates usage"}),"\n",(0,i.jsxs)(t.p,{children:["The code written to ",(0,i.jsx)(t.code,{children:"provide"})," & ",(0,i.jsx)(t.code,{children:"invalidate"})," tags for a given API slice will be dependent on multiple factors, including:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The shape of the data returned by your backend"}),"\n",(0,i.jsx)(t.li,{children:"Which tags you expect a given query endpoint to provide"}),"\n",(0,i.jsx)(t.li,{children:"Which tags you expect a given mutation endpoint to invalidate"}),"\n",(0,i.jsx)(t.li,{children:"The extent that you wish to use the invalidation feature for"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["When declaring your API slice, you may feel as though you're duplicating your code. For instance, for two separate endpoints that both provide a list of a particular entity, the ",(0,i.jsx)(t.code,{children:"providesTags"})," declaration may only differ in the ",(0,i.jsx)(t.code,{children:"tagType"})," provided."]}),"\n",(0,i.jsx)(t.p,{children:"e.g."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => `posts`,\n      // highlight-start\n      providesTags: (result) =>\n        result\n          ? [\n              { type: 'Post', id: 'LIST' },\n              ...result.map(({ id }) => ({ type: 'Post' as const, id })),\n            ]\n          : [{ type: 'Post', id: 'LIST' }],\n      // highlight-end\n    }),\n    getUsers: build.query<User[], void>({\n      query: () => `users`,\n      // highlight-start\n      providesTags: (result) =>\n        result\n          ? [\n              { type: 'User', id: 'LIST' },\n              ...result.map(({ id }) => ({ type: 'User' as const, id })),\n            ]\n          : [{ type: 'User', id: 'LIST' }],\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsx)(t.p,{children:"You may find it beneficial to define helper functions designed for your particular api to reduce this boilerplate across endpoint definitions, e.g."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"// file: types.ts noEmit\nexport interface Post {\n  id: number\n  name: string\n}\n\nexport interface User {\n  id: number\n  name: string\n}\n\n// file: api.ts\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post, User } from './types'\n\n// highlight-start\nfunction providesList<R extends { id: string | number }[], T extends string>(\n  resultsWithIds: R | undefined,\n  tagType: T,\n) {\n  return resultsWithIds\n    ? [\n        { type: tagType, id: 'LIST' },\n        ...resultsWithIds.map(({ id }) => ({ type: tagType, id })),\n      ]\n    : [{ type: tagType, id: 'LIST' }]\n}\n// highlight-end\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => `posts`,\n      // highlight-start\n      providesTags: (result) => providesList(result, 'Post'),\n      // highlight-end\n    }),\n    getUsers: build.query({\n      query: () => `users`,\n      // highlight-start\n      providesTags: (result) => providesList(result, 'User'),\n      // highlight-end\n    }),\n  }),\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["An example of various abstractions for tag providing/invalidating designed for common rest data formats can be seen in the following gist, including typescript support, and factoring both ",(0,i.jsx)(t.a,{href:"#advanced-invalidation-with-abstract-tag-ids",children:"'LIST' style advanced tag invalidation"})," and ",(0,i.jsx)(t.a,{href:"#providing-errors-to-the-cache",children:"'error' style tag invalidation"}),": ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"https://gist.github.com/Shrugsy/6b6af02aef1f783df9d636526c1e05fa",children:"RTK Query cache utils"})}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const s={},d=i.createContext(s);function a(e){const t=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(d.Provider,{value:t},e.children)}}}]);