"use strict";(self.webpackChunkredux_toolkit_zh=self.webpackChunkredux_toolkit_zh||[]).push([[9641],{2649:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>a});var i=t(4848),r=t(8453);const c={id:"combineSlices",title:"combineSlices",sidebar_label:"combineSlices",hide_title:!0},o="combineSlices",s={id:"api/combineSlices",title:"combineSlices",description:"&nbsp;",source:"@site/docs/api/combineSlices.mdx",sourceDirName:"api",slug:"/api/combineSlices",permalink:"/redux-toolkit-zh/api/combineSlices",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api/combineSlices.mdx",tags:[],version:"current",frontMatter:{id:"combineSlices",title:"combineSlices",sidebar_label:"combineSlices",hide_title:!0},sidebar:"docs",previous:{title:"createEntityAdapter",permalink:"/redux-toolkit-zh/api/createEntityAdapter"},next:{title:"createSelector",permalink:"/redux-toolkit-zh/api/createSelector"}},l={},a=[{value:"Overview",id:"overview",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"<code>withLazyLoadedSlices</code>",id:"withlazyloadedslices",level:3},{value:"<code>inject</code>",id:"inject",level:3},{value:"Reducer replacement",id:"reducer-replacement",level:4},{value:"<code>selector</code>",id:"selector",level:3},{value:"Nested combined reducer",id:"nested-combined-reducer",level:4},{value:"<code>original</code>",id:"original",level:4},{value:"Slice integration",id:"slice-integration",level:2},{value:"<code>injectInto</code>",id:"injectinto",level:3},{value:"<code>selectors</code> / <code>getSelectors</code>",id:"selectors--getselectors",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsx)(n.h1,{id:"combineslices",children:(0,i.jsx)(n.code,{children:"combineSlices"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"A function that combines slices into a single reducer, and enables injection of more reducers after initialisation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// file: slices/api.ts noEmit\nimport type { Api } from '@reduxjs/toolkit/query'\n\nexport declare const api: Api<() => any, {}, 'api', never>\n\n// file: slices/users.ts noEmit\nimport type { Slice } from '@reduxjs/toolkit'\n\nexport declare const userSlice: Slice<string, {}, 'user'>\n\n// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { api } from './api'\nimport { userSlice } from './users'\n\nexport const rootReducer = combineSlices(api, userSlice)\n\n// file: store.ts\nimport { configureStore } from '@reduxjs/toolkit'\nimport { rootReducer } from './slices'\n\nexport const store = configureStore({\n  reducer: rootReducer,\n})\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:['A "slice" for ',(0,i.jsx)(n.code,{children:"combineSlices"})," is typically created with ",(0,i.jsx)(n.a,{href:"/redux-toolkit-zh/api/createSlice",children:(0,i.jsx)(n.code,{children:"createSlice"})}),',\nbut can be any "slice-like" object with ',(0,i.jsx)(n.code,{children:"reducerPath"})," and ",(0,i.jsx)(n.code,{children:"reducer"})," properties (meaning RTK Query ",(0,i.jsx)(n.a,{href:"/redux-toolkit-zh/rtk-query/api/created-api/overview",children:"API instances"})," are also compatible)."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const withUserReducer = rootReducer.inject({\n  reducerPath: 'user',\n  reducer: userReducer,\n})\n\nconst withApiReducer = rootReducer.inject(fooApi)\n"})}),(0,i.jsxs)(n.p,{children:["For simplicity, this ",(0,i.jsx)(n.code,{children:"{ reducerPath, reducer }"}),' shape will be described in these docs as a "slice".']})]}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"combineSlices"})," accepts a set of slices and/or reducer map objects, and combines them into a single reducer."]}),"\n",(0,i.jsxs)(n.p,{children:["Slices will be mounted at their ",(0,i.jsx)(n.code,{children:"reducerPath"}),", and items from reducer map objects will be mounted under their respective key."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const rootReducer = combineSlices(counterSlice, baseApi, {\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n// is like\nconst rootReducer = combineReducers({\n  [counterSlice.reducerPath]: counterSlice.reducer,\n  [baseApi.reducerPath]: baseApi.reducer,\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"caution",children:[(0,i.jsx)(n.p,{children:"If multiple slices/map objects have the same reducer path, the reducer provided later in the arguments will override the previous."}),(0,i.jsx)(n.p,{children:"However, typing will not be able to account for this. It's best to ensure that all of your reducers will aim for a unique location."})]}),"\n",(0,i.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"combineSlices"})," returns a reducer function, with attached methods."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"interface CombinedSliceReducer<InitialState, DeclaredState = InitialState>\n  extends Reducer<DeclaredState, AnyAction, Partial<DeclaredState>> {\n  withLazyLoadedSlices<LazyLoadedSlices>(): CombinedSliceReducer<\n    InitialState,\n    DeclaredState & Partial<LazyLoadedSlices>\n  >\n  inject<Slice extends SliceLike>(\n    slice: Slice,\n    config?: InjectConfig\n  ): CombinedSliceReducer<InitialState, DeclaredState & WithSlice<Slice>>\n  selector: {\n    (selectorFn: Selector, selectState?: SelectFromRootState) => WrappedSelector\n    original(state: DeclaredState) => InitialState & Partial<DeclaredState>\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"withlazyloadedslices",children:(0,i.jsx)(n.code,{children:"withLazyLoadedSlices"})}),"\n",(0,i.jsxs)(n.p,{children:["It's recommended to ",(0,i.jsx)(n.a,{href:"https://redux.js.org/usage/usage-with-typescript#define-root-state-and-dispatch-types",children:"infer your RootState type from your store"}),", which is inferred from the reducer. However, this can present issues if slices are lazy loaded, and thus not able to be inferred from."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"withLazyLoadedSlices"})," allows you to declare slices that will be added to state later, which will be included in the final state type."]}),"\n",(0,i.jsx)(n.p,{children:"One possible pattern of managing this would be with declaration merging:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'no-transpile title="Using declaration merging to declare injected slices"',children:"// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { staticSlice } from './static'\n\nexport interface LazyLoadedSlices {}\n\nexport const rootReducer =\n  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()\n\n// keys in LazyLoadedSlices are marked as optional\nexport type RootState = ReturnType<typeof rootReducer>\n\n// file: slices/lazySlice.ts\nimport type { WithSlice } from '@reduxjs/toolkit'\nimport { rootReducer } from '.'\n\nconst lazySlice = createSlice({\n  /* ... */\n})\n\ndeclare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof lazySlice> {}\n}\n\nconst injectedReducer = rootReducer.inject(lazySlice)\n\n// and/or\n\nconst injectedSlice = lazySlice.injectInto(rootReducer)\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["The above example uses the ",(0,i.jsx)(n.code,{children:"WithSlice"})," utility type for a slice mounted under its ",(0,i.jsx)(n.code,{children:"reducerPath"}),". If the slice is mounted under a different key, you can declare it as a regular key instead."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'no-transpile title="Declaring a slice mounted outside its reducerPath"',children:"// file: slices/lazySlice.ts\nimport { rootReducer } from '.'\n\nconst lazySlice = createSlice({\n  /* ... */\n})\n\ndeclare module '.' {\n  export interface LazyLoadedSlices {\n    customKey: LazyState\n  }\n}\n\nconst injectedReducer = rootReducer.inject({\n  reducerPath: 'customKey',\n  reducer: lazySlice.reducer,\n})\n\n// and/or\n\nconst injectedSlice = lazySlice.injectInto(rootReducer, {\n  reducerPath: 'customKey',\n})\n"})})]}),"\n",(0,i.jsx)(n.h3,{id:"inject",children:(0,i.jsx)(n.code,{children:"inject"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"inject"})," allows you to add a slice to your set of reducers after initialisation.\nIt expects to be passed a slice and an optional config, and returns an updated version of the reducer with the slice included."]}),"\n",(0,i.jsx)(n.p,{children:"This is mainly useful for lazy loading reducers."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const reducerWithUser = rootReducer.inject(userSlice)\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"inject"})," adds the slice to the map of reducers in your original reducer, but doesn't dispatch an action."]}),(0,i.jsx)(n.p,{children:"This means that the added reducer state will not show up in your store until the next action is dispatched."})]}),"\n",(0,i.jsx)(n.h4,{id:"reducer-replacement",children:"Reducer replacement"}),"\n",(0,i.jsxs)(n.p,{children:["By default, replacing a reducer is not allowed.\nIn development mode, a warning will be logged to console if a new reducer instance is attempted to inject into a ",(0,i.jsx)(n.code,{children:"reducerPath"})," that's already injected. (It won't warn if the same reducer instance is injected into the same place twice.)"]}),"\n",(0,i.jsxs)(n.p,{children:["If you wish to allow replacing a reducer with a new instance, you must explicitly pass ",(0,i.jsx)(n.code,{children:"overrideExisting: true"})," as part of your configuration object."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const reducerWithUser = rootReducer.inject(userSlice, {\n  overrideExisting: true,\n})\n"})}),"\n",(0,i.jsxs)(n.p,{children:['This may be useful for hot reload, or "removing" a reducer by replacing it with a function that always returns ',(0,i.jsx)(n.code,{children:"null"}),".\nNote that for predictable behaviour, your types should account for all of the possible reducers you intend to occupy a path."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile title=\"'Removing' a reducer, by replacing it with a no-op function\"",children:"declare module '.' {\n  export interface LazyLoadedSlices {\n    removable: RemovableState | null\n  }\n}\n\nconst withInjected = rootReducer.inject(\n  { reducerPath: 'removable', reducer: removableReducer },\n  { overrideExisting: true },\n)\n\nconst emptyReducer = () => null\n\nconst removeReducer = () =>\n  rootReducer.inject(\n    { reducerPath: 'removable', reducer: emptyReducer },\n    { overrideExisting: true },\n  )\n"})}),"\n",(0,i.jsx)(n.h3,{id:"selector",children:(0,i.jsx)(n.code,{children:"selector"})}),"\n",(0,i.jsx)(n.p,{children:"As noted previously, an injected reducer can still be undefined in state if no action has been dispatched."}),"\n",(0,i.jsx)(n.p,{children:"Dealing with this possibly-optional state can be inconvient when writing selectors, as you may end up with a lot of results being possibly undefined or relying on explicit defaults."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"selector"})," allows you to get around this, by wrapping the reducer state in a ",(0,i.jsx)(n.code,{children:"Proxy"})," that ensures that any currently injected reducers evaluate to their initial state if they're currently ",(0,i.jsx)(n.code,{children:"undefined"})," in state."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"declare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    /* ... */\n  },\n})\n\nconst withCounter = rootReducer.inject(counterSlice)\n\nconst selectCounterValue = (rootState: RootState) => rootState.counter?.value // number | undefined\n\nconst wrappedSelectCounterValue = withCounter.selector(\n  (rootState) => rootState.counter.value, // number\n)\n\nconsole.log(\n  selectCounterValue({}), // undefined\n  selectCounterValue({ counter: { value: 2 } }), // 2\n  wrappedSelectCounterValue({}), // 0\n  wrappedSelectCounterValue({ counter: { value: 2 } }), // 2\n)\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Proxy"})," retrieves a reducer's initial state by calling it with a randomly generated action type - don't try to handle this as a special case inside your reducer."]})}),"\n",(0,i.jsx)(n.h4,{id:"nested-combined-reducer",children:"Nested combined reducer"}),"\n",(0,i.jsx)(n.p,{children:"The wrapped selector expects to use the state returned by the combined reducer as its first argument."}),"\n",(0,i.jsxs)(n.p,{children:["If the combined reducer is nested further inside the store state, pass a ",(0,i.jsx)(n.code,{children:"selectState"})," callback as the second argument to ",(0,i.jsx)(n.code,{children:"selector"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"interface RootState {\n  innerCombined: ReturnType<typeof combinedReducer>\n}\n\nconst selectCounterValue = withCounter.selector(\n  (combinedState) => combinedState.counter.value,\n  (rootState: RootState) => rootState.innerCombined,\n)\n\nconsole.log(\n  selectCounterValue({\n    innerCombined: {},\n  }), // 0\n  selectCounterValue({\n    innerCombined: {\n      counter: {\n        value: 2,\n      },\n    },\n  }), // 2\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"original",children:(0,i.jsx)(n.code,{children:"original"})}),"\n",(0,i.jsxs)(n.p,{children:["Similar to ",(0,i.jsx)(n.a,{href:"/redux-toolkit-zh/usage/immer-reducers#debugging-and-inspecting-drafted-state",children:"Immer usage"}),", an ",(0,i.jsx)(n.code,{children:"original"})," function is provided to retrieve the original state value provided to the ",(0,i.jsx)(n.code,{children:"Proxy"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This is mainly useful for debugging/inspecting, as ",(0,i.jsx)(n.code,{children:"Proxy"})," instances tend to be displayed in a format that's hard to read."]}),"\n",(0,i.jsxs)(n.p,{children:["The function is attached as a method on the ",(0,i.jsx)(n.code,{children:"selector"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const wrappedSelectCounterValue = withCounter.selector((rootState) => {\n  console.log(withCounter.selector.original(rootState))\n  return rootState.counter.value\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"slice-integration",children:"Slice integration"}),"\n",(0,i.jsx)(n.h3,{id:"injectinto",children:(0,i.jsx)(n.code,{children:"injectInto"})}),"\n",(0,i.jsxs)(n.p,{children:["Slice instances returned by ",(0,i.jsx)(n.a,{href:"./createSlice",children:(0,i.jsx)(n.code,{children:"createSlice"})})," have an attached ",(0,i.jsx)(n.code,{children:"injectInto"})," method, which receive an injectable reducer from ",(0,i.jsx)(n.code,{children:"combineSlices"}),' and returns an "injected" version of that slice.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const injectedCounterSlice = counterSlice.injectInto(rootReducer)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An optional configuration object can be passed. This follows ",(0,i.jsx)(n.a,{href:"#inject",children:(0,i.jsx)(n.code,{children:"inject"})}),"'s options with an additional ",(0,i.jsx)(n.code,{children:"reducerPath"})," field, for injecting the slice under a path other than its current ",(0,i.jsx)(n.code,{children:"reducerPath"})," property."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const aCounterSlice = counterSlice.injectInto(rootReducer, {\n  reducerPath: 'aCounter',\n})\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"selectors--getselectors",children:[(0,i.jsx)(n.code,{children:"selectors"})," / ",(0,i.jsx)(n.code,{children:"getSelectors"})]}),"\n",(0,i.jsxs)(n.p,{children:["Similar to ",(0,i.jsx)(n.a,{href:"#selector",children:(0,i.jsx)(n.code,{children:"selector"})}),', the selectors from an "injected" slice instance behave slightly differently.']}),"\n",(0,i.jsx)(n.p,{children:"If the slice state is undefined in the store state passed, the selector will instead be called with the slice's initial state."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"selectors"})," will also reflect the change in ",(0,i.jsx)(n.code,{children:"reducerPath"})," if one was made during injection."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"console.log(\n  injectedCounterSlice.selectors.selectValue({}), // 0\n  injectedCounterSlice.selectors.selectValue({ counter: { value: 2 } }), // 2\n  aCounterSlice.selectors.selectValue({ aCounter: { value: 2 } }), // 2\n)\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const r={},c=i.createContext(r);function o(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);